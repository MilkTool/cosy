// Generated by Haxe 4.1.0-rc.1+adc9ed1b2
(function ($hx_exports, $global) { "use strict";
$hx_exports["cosy"] = $hx_exports["cosy"] || {};
$hx_exports["cosy"]["Cosy"] = $hx_exports["cosy"]["Cosy"] || {};
var $estr = function() { return js.Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
Math.__name__ = true;
class Std {
	static string(s) {
		return js.Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
Std.__name__ = true;
class StringTools {
	static startsWith(s,start) {
		if(s.length >= start.length) {
			return s.lastIndexOf(start,0) == 0;
		} else {
			return false;
		}
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
var cosy = {};
cosy.AstPrinter = class cosy_AstPrinter {
	constructor() {
		this.isInClass = false;
		this.indentAmount = 0;
	}
	indent() {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.indentAmount;
		while(_g1 < _g2) {
			++_g1;
			_g.push("  ");
		}
		return _g.join("");
	}
	printBlock(statements) {
		this.indentAmount++;
		let _g = [];
		let _g1 = 0;
		while(_g1 < statements.length) {
			let stmt = statements[_g1++];
			_g.push(this.indent() + this.printStmt(stmt));
		}
		let s = _g.join("\n");
		this.indentAmount--;
		return "{\n" + s + "\n" + this.indent() + "}";
	}
	printExprBlock(exprs) {
		this.indentAmount++;
		let _g = [];
		let _g1 = 0;
		while(_g1 < exprs.length) {
			let expr = exprs[_g1++];
			_g.push(this.indent() + this.printExpr(expr));
		}
		let s = _g.join("\n");
		this.indentAmount--;
		return "{\n" + s + "\n" + this.indent() + "}";
	}
	printStmt(statement) {
		switch(statement._hx_index) {
		case 0:
			return this.printBlock(statement.statements);
		case 1:
			return statement.keyword.lexeme;
		case 2:
			return statement.keyword.lexeme;
		case 3:
			return "" + this.printExpr(statement.e);
		case 4:
			let _g = statement.name;
			return "for " + (_g != null ? _g.lexeme + " in " : "") + this.printExpr(statement.from) + ".." + this.printExpr(statement.to) + " " + this.printBlock(statement.body);
		case 5:
			return "for " + statement.name.lexeme + " in " + this.printExpr(statement.array) + " " + this.printBlock(statement.body);
		case 6:
			let _g1 = statement.cond;
			return "for " + (_g1 != null ? this.printExpr(_g1) : "") + " " + this.printBlock(statement.body);
		case 7:
			let _g2 = statement.foreign;
			let _g3 = statement.body;
			let _g4 = statement.params;
			let declaration = "" + (this.isInClass ? "" : _g2 ? "foreign fn" : "fn") + " " + statement.name.lexeme;
			let _g5 = [];
			let _g6 = 0;
			while(_g6 < _g4.length) _g5.push(this.formatParam(_g4[_g6++]));
			let parameters = _g5.join(", ");
			if(_g2) {
				return "" + declaration + "(" + parameters + ")";
			}
			return "" + declaration + "(" + parameters + ") " + this.printBlock(_g3);
		case 8:
			let _g7 = statement.el;
			return "if " + this.printExpr(statement.cond) + " " + this.printStmt(statement.then) + (_g7 != null ? " else " + this.printStmt(_g7) : "");
		case 9:
			return "" + statement.keyword.lexeme + " " + this.printExpr(statement.e);
		case 10:
			let _g8 = statement.value;
			return statement.keyword.lexeme + (_g8 != null ? " " + this.printExpr(_g8) : "");
		case 11:
			return "struct " + statement.name.lexeme + " " + this.printBlock(statement.declarations);
		case 12:
			let _g9 = statement.init;
			return "" + (statement.foreign ? "foreign " : "") + (statement.mut ? "mut" : "var") + " " + statement.name.lexeme + (_g9 != null ? " = " + this.printExpr(_g9) : "");
		}
	}
	printExpr(expr) {
		switch(expr._hx_index) {
		case 0:
			let _g = expr.exprs;
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _g.length) _g1.push(this.printExpr(_g[_g2++]));
			return "[" + _g1.join(",") + "]";
		case 1:
			return "" + expr.name.lexeme + " " + expr.op.lexeme + " " + this.printExpr(expr.value);
		case 2:
			return "" + this.printExpr(expr.left) + " " + expr.op.lexeme + " " + this.printExpr(expr.right);
		case 3:
			let _g3 = expr.$arguments;
			let tmp = "" + this.printExpr(expr.callee) + "(";
			let _g4 = [];
			let _g5 = 0;
			while(_g5 < _g3.length) _g4.push(this.printExpr(_g3[_g5++]));
			return tmp + _g4.join(", ") + ")";
		case 4:
			return "" + this.printExpr(expr.obj) + "." + expr.name.lexeme;
		case 5:
			return "(" + this.printExpr(expr.e) + ")";
		case 6:
			let _g6 = expr.v;
			if(typeof(_g6) == "string") {
				return "'" + (_g6 == null ? "null" : Std.string(_g6)) + "'";
			} else {
				return "" + (_g6 == null ? "null" : Std.string(_g6));
			}
			break;
		case 7:
			return "" + this.printExpr(expr.left) + " " + (expr.op.type._hx_index == 40 ? "or" : "and") + " " + this.printExpr(expr.right);
		case 8:
			return "mut " + expr.name.lexeme;
		case 9:
			return "" + this.printExpr(expr.obj) + "." + expr.name.lexeme + " = " + this.printExpr(expr.value);
		case 10:
			return this.printExprBlock(expr.decls);
		case 11:
			return "" + expr.op.lexeme + this.printExpr(expr.right);
		case 12:
			return expr.name.lexeme;
		case 13:
			let _g7 = expr.body;
			let _g8 = expr.params;
			let _g9 = [];
			let _g10 = 0;
			while(_g10 < _g8.length) _g9.push(this.formatParam(_g8[_g10++]));
			return "fn (" + _g9.join(",") + ") " + this.printStmt(cosy.Stmt.Block(_g7));
		}
	}
	formatType(type) {
		switch(type._hx_index) {
		case 0:
			return "";
		case 2:
			return "Bool";
		case 3:
			return "Num";
		case 4:
			return "Str";
		case 6:
			let _g = type.paramTypes;
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _g.length) _g1.push(this.formatType(_g[_g2++]));
			return "Fn(" + _g1.join(", ") + ")";
		case 7:
			return StringTools.trim("Array " + this.formatType(type.type));
		default:
			return "" + Std.string(type);
		}
	}
	formatParam(param) {
		let typeStr = this.formatType(param.type);
		return param.name.lexeme + (typeStr != "" ? " " + typeStr : "");
	}
}
cosy.AstPrinter.__name__ = true;
Object.assign(cosy.AstPrinter.prototype, {
	__class__: cosy.AstPrinter
});
cosy.Error = class cosy_Error {
	constructor(message) {
		this.message = message;
	}
}
cosy.Error.__name__ = true;
Object.assign(cosy.Error.prototype, {
	__class__: cosy.Error
});
cosy.Break = class cosy_Break extends cosy.Error {
	constructor(message) {
		super(message);
	}
}
cosy.Break.__name__ = true;
cosy.Break.__super__ = cosy.Error;
Object.assign(cosy.Break.prototype, {
	__class__: cosy.Break
});
cosy.Callable = class cosy_Callable {
}
cosy.Callable.__name__ = true;
Object.assign(cosy.Callable.prototype, {
	__class__: cosy.Callable
});
cosy.Continue = class cosy_Continue extends cosy.Error {
	constructor(message) {
		super(message);
	}
}
cosy.Continue.__name__ = true;
cosy.Continue.__super__ = cosy.Error;
Object.assign(cosy.Continue.prototype, {
	__class__: cosy.Continue
});
cosy.Interpreter = class cosy_Interpreter {
	constructor() {
		this.locals = new haxe.ds.ObjectMap();
		this.globals = new cosy.Environment();
		this.globals.define("clock",new cosy._Interpreter.ClockCallable());
		this.globals.define("random",new cosy._Interpreter.RandomCallable());
		this.environment = this.globals;
	}
	interpret(statements) {
		try {
			let _g = 0;
			while(_g < statements.length) this.execute(statements[_g++]);
		} catch( _g ) {
			let _g1 = haxe.Exception.caught(_g).unwrap();
			if(((_g1) instanceof cosy.RuntimeError)) {
				cosy.Cosy.runtimeError(_g1);
			} else if(!((_g1) instanceof haxe.io.Eof)) {
				throw _g;
			}
		}
	}
	execute(statement) {
		while(true) {
			switch(statement._hx_index) {
			case 0:
				this.executeBlock(statement.statements,new cosy.Environment(this.environment));
				break;
			case 1:
				throw haxe.Exception.thrown(new cosy.Break());
			case 2:
				throw haxe.Exception.thrown(new cosy.Continue());
			case 3:
				this.evaluate(statement.e);
				break;
			case 4:
				let _g = statement.body;
				let _g1 = statement.name;
				let _g2 = statement.keyword;
				let fromVal = this.evaluate(statement.from);
				if(typeof(fromVal) != "number") {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g2),"Number expected in \"from\" clause of loop.");
				}
				let toVal = this.evaluate(statement.to);
				if(typeof(toVal) != "number") {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g2),"Number expected in \"to\" clause of loop.");
				}
				let env = new cosy.Environment(this.environment);
				try {
					let _g2 = fromVal;
					let _g3 = toVal;
					while(_g2 < _g3) {
						let counter = _g2++;
						if(_g1 != null) {
							env.define(_g1.lexeme,counter);
						}
						try {
							this.executeBlock(_g,env);
						} catch( _g3 ) {
							if(!((haxe.Exception.caught(_g3).unwrap()) instanceof cosy.Continue)) {
								throw _g3;
							}
						}
					}
				} catch( _g3 ) {
					if(!((haxe.Exception.caught(_g3).unwrap()) instanceof cosy.Break)) {
						throw _g3;
					}
				}
				break;
			case 5:
				let _g4 = statement.body;
				let _g5 = statement.name;
				let arr = this.evaluate(statement.array);
				let env1 = new cosy.Environment(this.environment);
				try {
					let _g = 0;
					while(_g < arr.length) {
						env1.define(_g5.lexeme,arr[_g++]);
						try {
							this.executeBlock(_g4,env1);
						} catch( _g1 ) {
							if(!((haxe.Exception.caught(_g1).unwrap()) instanceof cosy.Continue)) {
								throw _g1;
							}
						}
					}
				} catch( _g6 ) {
					if(!((haxe.Exception.caught(_g6).unwrap()) instanceof cosy.Break)) {
						throw _g6;
					}
				}
				break;
			case 6:
				let _g7 = statement.body;
				let _g8 = statement.cond;
				let env2 = new cosy.Environment(this.environment);
				try {
					while(_g8 != null ? this.isTruthy(this.evaluate(_g8)) : true) try {
						this.executeBlock(_g7,env2);
					} catch( _g ) {
						if(!((haxe.Exception.caught(_g).unwrap()) instanceof cosy.Continue)) {
							throw _g;
						}
					}
				} catch( _g9 ) {
					if(!((haxe.Exception.caught(_g9).unwrap()) instanceof cosy.Break)) {
						throw _g9;
					}
				}
				break;
			case 7:
				let _g10 = statement.name;
				if(statement.foreign) {
					this.environment.define(_g10.lexeme,cosy.Cosy.foreignFunctions.h[_g10.lexeme]);
					return;
				}
				this.environment.define(_g10.lexeme,new cosy.Function(_g10,statement.params,statement.body,this.environment,false));
				break;
			case 8:
				let _g11 = statement.el;
				if(this.isTruthy(this.evaluate(statement.cond))) {
					statement = statement.then;
					continue;
				} else if(_g11 != null) {
					statement = _g11;
					continue;
				}
				break;
			case 9:
				cosy.Cosy.println(this.stringify(this.evaluate(statement.e)));
				break;
			case 10:
				let _g12 = statement.value;
				throw haxe.Exception.thrown(new cosy.Return(_g12 == null ? null : this.evaluate(_g12)));
			case 11:
				let _g13 = statement.declarations;
				let _g14 = statement.name;
				this.environment.define(_g14.lexeme,null);
				let previousEnv = this.environment;
				this.environment = new cosy.Environment(this.environment);
				let fields = new haxe.ds.StringMap();
				let _g15 = 0;
				while(_g15 < _g13.length) {
					let decl = _g13[_g15];
					++_g15;
					if(decl._hx_index == 12) {
						let _g = decl.init;
						let key = decl.name.lexeme;
						let value = _g != null ? this.evaluate(_g) : null;
						fields.h[key] = value;
					}
				}
				this.environment = previousEnv;
				this.environment.assign(_g14,new cosy.StructInstance(_g14,fields));
				break;
			case 12:
				let _g16 = statement.init;
				let _g17 = statement.name;
				if(statement.foreign) {
					this.environment.define(_g17.lexeme,cosy.Cosy.foreignVariables.h[_g17.lexeme]);
					return;
				}
				let value = cosy.Interpreter.uninitialized;
				if(_g16 != null) {
					value = this.evaluate(_g16);
				}
				if(((value) instanceof cosy.StructInstance)) {
					value = value.clone();
				}
				this.environment.define(_g17.lexeme,value);
				break;
			}
			return;
		}
	}
	resolve(expr,depth) {
		this.locals.set(expr,depth);
	}
	executeBlock(statements,environment) {
		let previous = this.environment;
		try {
			this.environment = environment;
			let _g = 0;
			while(_g < statements.length) this.execute(statements[_g++]);
			this.environment = previous;
		} catch( _g ) {
			let _g1 = haxe.Exception.caught(_g).unwrap();
			this.environment = previous;
			throw haxe.Exception.thrown(_g1);
		}
	}
	evaluate(expr) {
		while(true) switch(expr._hx_index) {
		case 0:
			let _g = expr.exprs;
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _g.length) _g1.push(this.evaluate(_g[_g2++]));
			return _g1;
		case 1:
			let _g3 = expr.value;
			let _g4 = expr.op;
			let _g5 = expr.name;
			let value;
			switch(_g4.type._hx_index) {
			case 11:
				let left = this.lookUpVariable(_g5,expr);
				let right = this.evaluate(_g3);
				this.checkNumberOperands(_g4,left,right);
				value = left - right;
				break;
			case 13:
				let left1 = this.lookUpVariable(_g5,expr);
				let right1 = this.evaluate(_g3);
				if(typeof(left1) == "number" && typeof(right1) == "number") {
					value = left1 + right1;
				} else if(typeof(left1) == "number" && typeof(right1) == "string") {
					value = left1 + right1;
				} else if(typeof(left1) == "string" && typeof(right1) == "number") {
					value = left1 + right1;
				} else if(typeof(left1) == "string" && typeof(right1) == "string") {
					value = left1 + right1;
				} else {
					throw haxe.Exception.thrown(new cosy.RuntimeError(_g4,"Operands cannot be concatinated."));
				}
				break;
			case 15:
				let left2 = this.lookUpVariable(_g5,expr);
				let right2 = this.evaluate(_g3);
				this.checkNumberOperands(_g4,left2,right2);
				value = left2 / right2;
				break;
			case 17:
				let left3 = this.lookUpVariable(_g5,expr);
				let right3 = this.evaluate(_g3);
				this.checkNumberOperands(_g4,left3,right3);
				value = left3 * right3;
				break;
			case 20:
				value = this.evaluate(_g3);
				break;
			default:
				throw haxe.Exception.thrown("error");
			}
			let _g6 = this.locals.h[expr.__id__];
			if(_g6 == null) {
				this.globals.assign(_g5,value);
			} else {
				this.environment.assignAt(_g6,_g5,value);
			}
			return value;
		case 2:
			let _g7 = expr.op;
			let left4 = this.evaluate(expr.left);
			let right4 = this.evaluate(expr.right);
			switch(_g7.type._hx_index) {
			case 10:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 - right4;
			case 12:
				if(typeof(left4) == "number" && typeof(right4) == "number") {
					return left4 + right4;
				} else if(typeof(left4) == "number" && typeof(right4) == "string") {
					return left4 + right4;
				} else if(typeof(left4) == "string" && typeof(right4) == "number") {
					return left4 + right4;
				} else if(typeof(left4) == "string" && typeof(right4) == "string") {
					return left4 + right4;
				} else {
					throw haxe.Exception.thrown(new cosy.RuntimeError(_g7,"Operands cannot be concatinated."));
				}
				break;
			case 14:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 / right4;
			case 16:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 * right4;
			case 19:
				return !this.isEqual(left4,right4);
			case 21:
				return this.isEqual(left4,right4);
			case 22:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 > right4;
			case 23:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 >= right4;
			case 24:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 < right4;
			case 25:
				this.checkNumberOperands(_g7,left4,right4);
				return left4 <= right4;
			default:
				return null;
			}
			break;
		case 3:
			let _g8 = expr.$arguments;
			let _g9 = expr.paren;
			let callee = this.evaluate(expr.callee);
			let f = $bind(this,this.evaluate);
			let result = new Array(_g8.length);
			let _g10 = 0;
			let _g11 = _g8.length;
			while(_g10 < _g11) {
				let i = _g10++;
				result[i] = f(_g8[i]);
			}
			if(!js.Boot.__implements(callee,cosy.Callable)) {
				throw haxe.Exception.thrown(new cosy.RuntimeError(_g9,"Can only call functions and classes"));
			} else {
				let func = callee;
				if(!((func) instanceof cosy.ForeignFunction)) {
					let arity = func.arity();
					if(result.length != arity) {
						throw haxe.Exception.thrown(new cosy.RuntimeError(_g9,"Expected " + arity + " argument(s) but got " + result.length + "."));
					}
				}
				return func.call(this,result);
			}
			break;
		case 4:
			let _g12 = expr.name;
			let obj = this.evaluate(expr.obj);
			if(((obj) instanceof Array)) {
				return this.arrayGet(obj,_g12);
			} else if(((obj) instanceof cosy.StructInstance)) {
				return obj.get(_g12);
			} else if(typeof(obj) == "string") {
				return this.stringGet(obj,_g12);
			} else {
				throw haxe.Exception.thrown(new cosy.RuntimeError(_g12,"Only instances have properties"));
			}
			break;
		case 5:
			expr = expr.e;
			continue;
		case 6:
			return expr.v;
		case 7:
			let _g13 = expr.right;
			let left5 = this.evaluate(expr.left);
			switch(expr.op.type._hx_index) {
			case 29:
				if(!this.isTruthy(left5)) {
					return left5;
				} else {
					expr = _g13;
					continue;
				}
				break;
			case 40:
				if(this.isTruthy(left5)) {
					return left5;
				} else {
					expr = _g13;
					continue;
				}
				break;
			default:
				expr = _g13;
				continue;
			}
			break;
		case 8:
			return this.lookUpVariable(expr.name,expr);
		case 9:
			let _g14 = expr.name;
			let obj1 = this.evaluate(expr.obj);
			let value1 = this.evaluate(expr.value);
			if(((obj1) instanceof cosy.StructInstance)) {
				obj1.set(_g14,value1);
			} else {
				throw haxe.Exception.thrown(new cosy.RuntimeError(_g14,"Only instances have fields"));
			}
			return value1;
		case 10:
			let _g15 = expr.decls;
			let _g16 = expr.name;
			let structObj = this.lookUpVariable(_g16,expr);
			if(!((structObj) instanceof cosy.StructInstance)) {
				throw haxe.Exception.thrown(new cosy.RuntimeError(_g16,"Struct initializer on non-struct object."));
			}
			structObj = structObj.clone();
			let _g17 = 0;
			while(_g17 < _g15.length) {
				let decl = _g15[_g17];
				++_g17;
				if(decl._hx_index == 1) {
					structObj.set(decl.name,this.evaluate(decl.value));
				}
			}
			return structObj;
		case 11:
			let _g18 = expr.op;
			let right5 = this.evaluate(expr.right);
			switch(_g18.type._hx_index) {
			case 10:
				this.checkNumberOperand(_g18,right5);
				return -right5;
			case 18:
				return !this.isTruthy(right5);
			default:
				return null;
			}
			break;
		case 12:
			return this.lookUpVariable(expr.name,expr);
		case 13:
			return new cosy.Function(null,expr.params,expr.body,this.environment,false);
		}
	}
	arrayGet(array,name) {
		switch(name.lexeme) {
		case "concat":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				let _this = args[0];
				let f = $bind(array,$arrayPush);
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = f(_this[i]);
				}
				return result;
			});
		case "contains":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				return array.indexOf(args[0]) != -1;
			});
		case "get":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				return array[args[0]];
			});
		case "length":
			return array.length;
		case "pop":
			return new cosy._Interpreter.CustomCallable(0,function(_) {
				if(array.length == 0) {
					throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Cannot pop from empty array."));
				} else {
					return array.pop();
				}
			});
		case "push":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				let f = $bind(array,$arrayPush);
				let result = new Array(args.length);
				let _g = 0;
				let _g1 = args.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = f(args[i]);
				}
				return result;
			});
		default:
			throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Undefined method \"" + name.lexeme + "\"."));
		}
	}
	stringGet(string,name) {
		switch(name.lexeme) {
		case "charAt":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				return string.charAt(args[0]);
			});
		case "length":
			return string.length;
		case "split":
			return new cosy._Interpreter.CustomCallable(1,function(args) {
				return string.split(args[0]);
			});
		default:
			throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Undefined method \"" + name.lexeme + "\"."));
		}
	}
	lookUpVariable(name,expr) {
		let _g = this.locals.h[expr.__id__];
		let value = _g == null ? this.globals.get(name) : this.environment.getAt(_g,name.lexeme);
		if(value == cosy.Interpreter.uninitialized) {
			throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Accessing uninitialized variable \"" + name.lexeme + "\"."));
		}
		return value;
	}
	isTruthy(v) {
		if(v == null) {
			return false;
		}
		if(typeof(v) == "boolean") {
			return v;
		}
		return true;
	}
	isEqual(a,b) {
		if(a == null && b == null) {
			return true;
		}
		if(a == null) {
			return false;
		}
		return a == b;
	}
	checkNumberOperand(op,operand) {
		if(typeof(operand) == "number") {
			return;
		}
		throw haxe.Exception.thrown(new cosy.RuntimeError(op,"Operand must be a number"));
	}
	checkNumberOperands(op,left,right) {
		if(typeof(left) == "number" && typeof(right) == "number") {
			return;
		}
		throw haxe.Exception.thrown(new cosy.RuntimeError(op,"Operand must be a number"));
	}
	stringify(v) {
		if(v == null) {
			return "nil";
		}
		return "" + (v == null ? "null" : Std.string(v));
	}
}
cosy.Interpreter.__name__ = true;
Object.assign(cosy.Interpreter.prototype, {
	__class__: cosy.Interpreter
});
cosy.Environment = class cosy_Environment {
	constructor(enclosing) {
		this.values = new haxe.ds.StringMap();
		this.enclosing = enclosing;
	}
	define(name,value) {
		this.values.h[name] = value;
	}
	get(name) {
		if(Object.prototype.hasOwnProperty.call(this.values.h,name.lexeme)) {
			return this.values.h[name.lexeme];
		}
		if(this.enclosing != null) {
			return this.enclosing.get(name);
		}
		throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Undefined variable \"" + name.lexeme + "\"."));
	}
	getAt(distance,name) {
		return this.ancestor(distance).values.h[name];
	}
	assign(name,value) {
		if(Object.prototype.hasOwnProperty.call(this.values.h,name.lexeme)) {
			this.values.h[name.lexeme] = value;
		} else if(this.enclosing != null) {
			this.enclosing.assign(name,value);
		} else {
			throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Undefined variable \"" + name.lexeme + "\"."));
		}
	}
	assignAt(distance,name,value) {
		this.ancestor(distance).values.h[name.lexeme] = value;
	}
	ancestor(distance) {
		let env = this;
		let _g = 0;
		while(_g < distance) {
			++_g;
			env = env.enclosing;
		}
		return env;
	}
}
cosy.Environment.__name__ = true;
Object.assign(cosy.Environment.prototype, {
	__class__: cosy.Environment
});
cosy._Interpreter = {};
cosy._Interpreter.ClockCallable = class cosy__$Interpreter_ClockCallable {
	constructor() {
	}
	arity() {
		return 0;
	}
	call(interpreter,args) {
		return HxOverrides.now() / 1000 * 1000;
	}
	toString() {
		return "<native fn>";
	}
}
cosy._Interpreter.ClockCallable.__name__ = true;
cosy._Interpreter.ClockCallable.__interfaces__ = [cosy.Callable];
Object.assign(cosy._Interpreter.ClockCallable.prototype, {
	__class__: cosy._Interpreter.ClockCallable
});
cosy._Interpreter.RandomCallable = class cosy__$Interpreter_RandomCallable {
	constructor() {
	}
	arity() {
		return 0;
	}
	call(interpreter,args) {
		return Math.random();
	}
	toString() {
		return "<native fn>";
	}
}
cosy._Interpreter.RandomCallable.__name__ = true;
cosy._Interpreter.RandomCallable.__interfaces__ = [cosy.Callable];
Object.assign(cosy._Interpreter.RandomCallable.prototype, {
	__class__: cosy._Interpreter.RandomCallable
});
cosy.Cosy = class cosy_Cosy {
	static main() {
		cosy.Cosy.setFunction("randomInt",function(args) {
			return Std.random(args[0]);
		});
		cosy.Cosy.setFunction("readInput",function(args) {
			throw haxe.Exception.thrown("Not implemented on this platform!");
		});
		cosy.Cosy.setFunction("stringToNumber",function(args) {
			return Std.parseInt(args[0]);
		});
	}
	static println(v) {
		if(cosy.Cosy.testing) {
			cosy.Cosy.testOutput += Std.string(v) + "\n";
		} else {
			$global.console.log(v);
		}
	}
	static validate(source) {
		cosy.Cosy.hadError = false;
		let statements = new cosy.Parser(new cosy.Scanner(source).scanTokens()).parse();
		if(cosy.Cosy.hadError) {
			return;
		}
		let resolver = new cosy.Resolver(cosy.Cosy.interpreter);
		resolver.beginScope();
		resolver.resolveStmts(statements);
		resolver.endScope();
		new cosy.Typer().typeStmts(statements);
		if(cosy.Cosy.hadError) {
			return;
		}
	}
	static setFunction(name,func) {
		cosy.Cosy.foreignFunctions.h[name] = new cosy.ForeignFunction(func);
	}
	static setVariable(name,variable) {
		cosy.Cosy.foreignVariables.h[name] = variable;
	}
	static run(source) {
		cosy.Cosy.hadError = false;
		let statements = new cosy.Parser(new cosy.Scanner(source).scanTokens()).parse();
		if(cosy.Cosy.hadError) {
			return;
		}
		let resolver = new cosy.Resolver(cosy.Cosy.interpreter);
		resolver.beginScope();
		resolver.resolveStmts(statements);
		resolver.endScope();
		new cosy.Typer().typeStmts(statements);
		if(cosy.Cosy.hadError) {
			return;
		}
		statements = new cosy.Optimizer().optimizeStmts(statements);
		if(cosy.Cosy.prettyPrint) {
			let printer = new cosy.AstPrinter();
			let _g = 0;
			while(_g < statements.length) cosy.Cosy.println(printer.printStmt(statements[_g++]));
			return;
		}
		if(cosy.Cosy.javascript) {
			cosy.Cosy.println("// standard library\nlet clock = Date.now;\n");
			let printer = new cosy.JavaScriptPrinter();
			let _g = 0;
			while(_g < statements.length) cosy.Cosy.println(printer.printStmt(statements[_g++]));
			return;
		}
		cosy.Cosy.interpreter.interpret(statements);
	}
	static reportWarning(line,where,message) {
		cosy.Cosy.println("[line " + line + "] Warning " + where + ": " + message);
	}
	static warning(data,message) {
		switch(data._hx_index) {
		case 0:
			cosy.Cosy.reportWarning(data.v,"",message);
			break;
		case 1:
			let _g = data.v;
			if(_g.type == cosy.TokenType.Eof) {
				cosy.Cosy.reportWarning(_g.line,"at end",message);
			} else {
				cosy.Cosy.reportWarning(_g.line,"at \"" + _g.lexeme + "\"",message);
			}
			break;
		}
	}
	static report(line,where,message) {
		cosy.Cosy.println("[line " + line + "] Error " + where + ": " + message);
		cosy.Cosy.hadError = true;
	}
	static error(data,message) {
		switch(data._hx_index) {
		case 0:
			cosy.Cosy.report(data.v,"",message);
			break;
		case 1:
			let _g = data.v;
			if(_g.type == cosy.TokenType.Eof) {
				cosy.Cosy.report(_g.line,"at end",message);
			} else {
				cosy.Cosy.report(_g.line,"at \"" + _g.lexeme + "\"",message);
			}
			break;
		}
	}
	static runtimeError(e) {
		cosy.Cosy.println("[line " + e.token.line + "] Runtime Error: " + e.message);
		cosy.Cosy.hadRuntimeError = true;
	}
}
$hx_exports["cosy"]["Cosy"]["run"] = cosy.Cosy.run;
$hx_exports["cosy"]["Cosy"]["setVariable"] = cosy.Cosy.setVariable;
$hx_exports["cosy"]["Cosy"]["setFunction"] = cosy.Cosy.setFunction;
$hx_exports["cosy"]["Cosy"]["validate"] = cosy.Cosy.validate;
cosy.Cosy.__name__ = true;
cosy.ErrorDataType = $hxEnums["cosy.ErrorDataType"] = { __ename__ : true, __constructs__ : ["Line","Token"]
	,Line: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"cosy.ErrorDataType",toString:$estr}; },$_.__params__ = ["v"],$_)
	,Token: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"cosy.ErrorDataType",toString:$estr}; },$_.__params__ = ["v"],$_)
};
cosy.ForeignFunction = class cosy_ForeignFunction {
	constructor(method) {
		this.method = method;
	}
	arity() {
		return 0;
	}
	call(interpreter,args) {
		return this.method(args);
	}
	toString() {
		return "<foreign fn>";
	}
}
cosy.ForeignFunction.__name__ = true;
cosy.ForeignFunction.__interfaces__ = [cosy.Callable];
Object.assign(cosy.ForeignFunction.prototype, {
	__class__: cosy.ForeignFunction
});
cosy.Expr = $hxEnums["cosy.Expr"] = { __ename__ : true, __constructs__ : ["ArrayLiteral","Assign","Binary","Call","Get","Grouping","Literal","Logical","MutArgument","Set","StructInit","Unary","Variable","AnonFunction"]
	,ArrayLiteral: ($_=function(keyword,exprs) { return {_hx_index:0,keyword:keyword,exprs:exprs,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["keyword","exprs"],$_)
	,Assign: ($_=function(name,op,value) { return {_hx_index:1,name:name,op:op,value:value,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["name","op","value"],$_)
	,Binary: ($_=function(left,op,right) { return {_hx_index:2,left:left,op:op,right:right,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["left","op","right"],$_)
	,Call: ($_=function(callee,paren,$arguments) { return {_hx_index:3,callee:callee,paren:paren,$arguments:$arguments,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["callee","paren","$arguments"],$_)
	,Get: ($_=function(obj,name) { return {_hx_index:4,obj:obj,name:name,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["obj","name"],$_)
	,Grouping: ($_=function(e) { return {_hx_index:5,e:e,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["e"],$_)
	,Literal: ($_=function(v) { return {_hx_index:6,v:v,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["v"],$_)
	,Logical: ($_=function(left,op,right) { return {_hx_index:7,left:left,op:op,right:right,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["left","op","right"],$_)
	,MutArgument: ($_=function(keyword,name) { return {_hx_index:8,keyword:keyword,name:name,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["keyword","name"],$_)
	,Set: ($_=function(obj,name,value) { return {_hx_index:9,obj:obj,name:name,value:value,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["obj","name","value"],$_)
	,StructInit: ($_=function(name,decls) { return {_hx_index:10,name:name,decls:decls,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["name","decls"],$_)
	,Unary: ($_=function(op,right) { return {_hx_index:11,op:op,right:right,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["op","right"],$_)
	,Variable: ($_=function(name) { return {_hx_index:12,name:name,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["name"],$_)
	,AnonFunction: ($_=function(params,body,returnType) { return {_hx_index:13,params:params,body:body,returnType:returnType,__enum__:"cosy.Expr",toString:$estr}; },$_.__params__ = ["params","body","returnType"],$_)
};
cosy.Function = class cosy_Function {
	constructor(name,params,body,closure,isInitializer) {
		this.name = name;
		this.params = params;
		this.body = body;
		this.closure = closure;
		this.isInitializer = isInitializer;
	}
	arity() {
		return this.params.length;
	}
	call(interpreter,args) {
		let environment = new cosy.Environment(this.closure);
		let _g = 0;
		let _g1 = this.params.length;
		while(_g < _g1) {
			let i = _g++;
			environment.define(this.params[i].name.lexeme,args[i]);
		}
		try {
			interpreter.executeBlock(this.body,environment);
		} catch( _g2 ) {
			let _g = haxe.Exception.caught(_g2).unwrap();
			if(((_g) instanceof cosy.Return)) {
				if(!this.isInitializer) {
					return _g.value;
				}
			} else {
				throw _g2;
			}
		}
		if(this.isInitializer) {
			return this.closure.getAt(0,"this");
		} else {
			return null;
		}
	}
	toString() {
		if(this.name != null) {
			return "<fn " + this.name.lexeme + ">";
		} else {
			return "<fn>";
		}
	}
}
cosy.Function.__name__ = true;
cosy.Function.__interfaces__ = [cosy.Callable];
Object.assign(cosy.Function.prototype, {
	__class__: cosy.Function
});
cosy._Interpreter.CustomCallable = class cosy__$Interpreter_CustomCallable {
	constructor(arityValue,method) {
		this.arityValue = arityValue;
		this.method = method;
	}
	arity() {
		return this.arityValue;
	}
	call(interpreter,args) {
		return this.method(args);
	}
	toString() {
		return "<native fn>";
	}
}
cosy._Interpreter.CustomCallable.__name__ = true;
cosy._Interpreter.CustomCallable.__interfaces__ = [cosy.Callable];
Object.assign(cosy._Interpreter.CustomCallable.prototype, {
	__class__: cosy._Interpreter.CustomCallable
});
cosy.JavaScriptPrinter = class cosy_JavaScriptPrinter {
	constructor() {
		this.classNames = [];
		this.isInClass = false;
		this.indentAmount = 0;
	}
	indent() {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.indentAmount;
		while(_g1 < _g2) {
			++_g1;
			_g.push("  ");
		}
		return _g.join("");
	}
	printBlock(statements) {
		this.indentAmount++;
		let _g = [];
		let _g1 = 0;
		while(_g1 < statements.length) {
			let stmt = statements[_g1++];
			_g.push(this.indent() + this.printStmt(stmt));
		}
		let s = _g.join("\n");
		this.indentAmount--;
		return "{\n" + s + "\n" + this.indent() + "}";
	}
	printStmt(statement) {
		switch(statement._hx_index) {
		case 0:
			return this.printBlock(statement.statements);
		case 1:
			return "break;";
		case 2:
			return "continue;";
		case 3:
			return "" + this.printExpr(statement.e) + ";";
		case 4:
			let _g = statement.name;
			let counter = _g != null ? _g.lexeme : "__i";
			return "for (var " + counter + " = " + this.printExpr(statement.from) + "; " + counter + " < " + this.printExpr(statement.to) + "; " + counter + "++) " + this.printBlock(statement.body);
		case 5:
			return "for (" + statement.name.lexeme + " of " + this.printExpr(statement.array) + ") " + this.printBlock(statement.body);
		case 6:
			let _g1 = statement.cond;
			return "while (" + (_g1 != null ? this.printExpr(_g1) : "true") + ") " + this.printBlock(statement.body);
		case 7:
			let _g2 = statement.body;
			let _g3 = statement.params;
			if(statement.foreign) {
				return "";
			}
			let declaration = "" + (this.isInClass ? "" : "function ") + statement.name.lexeme;
			let _g4 = [];
			let _g5 = 0;
			while(_g5 < _g3.length) _g4.push(_g3[_g5++].name.lexeme);
			return "" + declaration + "(" + _g4.join(",") + ") " + this.printStmt(cosy.Stmt.Block(_g2));
		case 8:
			let _g6 = statement.el;
			return "if (" + this.printExpr(statement.cond) + ") " + this.printStmt(statement.then) + (_g6 != null ? " else " + this.printStmt(_g6) : "");
		case 9:
			return "console.log(" + this.printExpr(statement.e) + ");";
		case 10:
			let _g7 = statement.value;
			return "return" + (_g7 != null ? " " + this.printExpr(_g7) : "") + ";";
		case 11:
			return "// " + statement.name.lexeme + " struct";
		case 12:
			let _g8 = statement.init;
			if(statement.foreign) {
				return "";
			}
			return "" + (statement.mut ? "var" : "const") + " " + statement.name.lexeme + (_g8 != null ? " = " + this.printExpr(_g8) : "") + ";";
		}
	}
	printExpr(expr) {
		switch(expr._hx_index) {
		case 0:
			let _g = expr.exprs;
			let f = $bind(this,this.printExpr);
			let result = new Array(_g.length);
			let _g1 = 0;
			let _g2 = _g.length;
			while(_g1 < _g2) {
				let i = _g1++;
				result[i] = f(_g[i]);
			}
			return "[" + result.join(", ") + "]";
		case 1:
			return "" + expr.name.lexeme + " " + expr.op.lexeme + " " + this.printExpr(expr.value);
		case 2:
			let _g3 = expr.op;
			return "" + this.printExpr(expr.left) + " " + (_g3.type._hx_index == 21 ? "===" : _g3.lexeme) + " " + this.printExpr(expr.right);
		case 3:
			let _g4 = expr.$arguments;
			let calleeName = this.printExpr(expr.callee);
			let tmp = this.classNames.indexOf(calleeName) != -1 ? "new " : "";
			let tmp1 = "" + calleeName + "(";
			let f1 = $bind(this,this.printExpr);
			let result1 = new Array(_g4.length);
			let _g5 = 0;
			let _g6 = _g4.length;
			while(_g5 < _g6) {
				let i = _g5++;
				result1[i] = f1(_g4[i]);
			}
			return tmp + (tmp1 + result1.join(",") + ")");
		case 4:
			return "" + this.printExpr(expr.obj) + "." + expr.name.lexeme;
		case 5:
			return "(" + this.printExpr(expr.e) + ")";
		case 6:
			let _g7 = expr.v;
			if(_g7 == null) {
				return "null";
			} else if(typeof(_g7) == "string") {
				return "\"" + (_g7 == null ? "null" : Std.string(_g7)) + "\"";
			} else {
				return "" + (_g7 == null ? "null" : Std.string(_g7));
			}
			break;
		case 7:
			return "" + this.printExpr(expr.left) + " " + (expr.op.type._hx_index == 40 ? "||" : "&&") + " " + this.printExpr(expr.right);
		case 8:
			return expr.name.lexeme;
		case 9:
			return "" + this.printExpr(expr.obj) + "." + expr.name.lexeme + " = " + this.printExpr(expr.value);
		case 10:
			let _g8 = expr.decls;
			let _g9 = [];
			let _g10 = 0;
			while(_g10 < _g8.length) _g9.push(StringTools.replace(this.printExpr(_g8[_g10++])," = ",": "));
			return "{ " + _g9.join(", ") + " }";
		case 11:
			return "" + expr.op.lexeme + this.printExpr(expr.right);
		case 12:
			return expr.name.lexeme;
		case 13:
			let _g11 = expr.body;
			let _g12 = expr.params;
			let _g13 = [];
			let _g14 = 0;
			while(_g14 < _g12.length) _g13.push(_g12[_g14++].name.lexeme);
			return "function (" + _g13.join(", ") + ") " + this.printStmt(cosy.Stmt.Block(_g11));
		}
	}
}
cosy.JavaScriptPrinter.__name__ = true;
Object.assign(cosy.JavaScriptPrinter.prototype, {
	__class__: cosy.JavaScriptPrinter
});
cosy.Optimizer = class cosy_Optimizer {
	constructor() {
	}
	optimizeStmts(stmts) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < stmts.length) _g.push(this.optimizeStmt(stmts[_g1++]));
		return _g;
	}
	optimizeStmt(stmt) {
		switch(stmt._hx_index) {
		case 0:
			return cosy.Stmt.Block(this.optimizeStmts(stmt.statements));
		case 3:
			return cosy.Stmt.Expression(this.optimizeExpr(stmt.e));
		case 8:
			let _g = stmt.el;
			return cosy.Stmt.If(this.optimizeExpr(stmt.cond),this.optimizeStmt(stmt.then),_g != null ? this.optimizeStmt(_g) : null);
		case 9:
			return cosy.Stmt.Print(stmt.keyword,this.optimizeExpr(stmt.e));
		case 10:
			let _g1 = stmt.value;
			return cosy.Stmt.Return(stmt.keyword,_g1 != null ? this.optimizeExpr(_g1) : null);
		case 12:
			let _g2 = stmt.init;
			return cosy.Stmt.Var(stmt.name,stmt.type,_g2 != null ? this.optimizeExpr(_g2) : _g2,stmt.mut,stmt.foreign);
		default:
			return stmt;
		}
	}
	optimizeExpr(expr) {
		switch(expr._hx_index) {
		case 2:
			let _g = expr.op;
			let l = this.optimizeExpr(expr.left);
			let r = this.optimizeExpr(expr.right);
			if(l._hx_index == 6) {
				let _g1 = l.v;
				if(r._hx_index == 6) {
					let _g2 = r.v;
					if(typeof(_g1) == "number" && typeof(_g2) == "number") {
						let tmp;
						switch(_g.type._hx_index) {
						case 10:
							tmp = _g1 - _g2;
							break;
						case 12:
							tmp = _g1 + _g2;
							break;
						case 14:
							tmp = _g1 / _g2;
							break;
						case 16:
							tmp = _g1 * _g2;
							break;
						case 19:
							tmp = _g1 != _g2;
							break;
						case 21:
							tmp = _g1 == _g2;
							break;
						case 22:
							tmp = _g1 > _g2;
							break;
						case 23:
							tmp = _g1 >= _g2;
							break;
						case 24:
							tmp = _g1 < _g2;
							break;
						case 25:
							tmp = _g1 <= _g2;
							break;
						default:
							cosy.Cosy.error(cosy.ErrorDataType.Token(_g),"Invalid operator.");
							return cosy.Expr.Binary(l,_g,r);
						}
						return cosy.Expr.Literal(tmp);
					} else if(typeof(_g1) == "string" && typeof(_g2) == "string") {
						return cosy.Expr.Literal(_g1 + _g2);
					} else {
						return cosy.Expr.Binary(l,_g,r);
					}
				} else {
					return cosy.Expr.Binary(l,_g,r);
				}
			} else {
				return cosy.Expr.Binary(l,_g,r);
			}
			break;
		case 7:
			let _g1 = expr.op;
			let l1 = this.optimizeExpr(expr.left);
			let r1 = this.optimizeExpr(expr.right);
			if(l1._hx_index == 6) {
				let _g = l1.v;
				if(r1._hx_index == 6) {
					let _g2 = r1.v;
					if(typeof(_g) == "boolean" && typeof(_g2) == "boolean") {
						let tmp;
						switch(_g1.type._hx_index) {
						case 29:
							tmp = _g && _g2;
							break;
						case 40:
							tmp = _g || _g2;
							break;
						default:
							cosy.Cosy.error(cosy.ErrorDataType.Token(_g1),"Invalid operator.");
							return cosy.Expr.Binary(l1,_g1,r1);
						}
						return cosy.Expr.Literal(tmp);
					} else {
						return cosy.Expr.Logical(l1,_g1,r1);
					}
				} else {
					return cosy.Expr.Logical(l1,_g1,r1);
				}
			} else {
				return cosy.Expr.Logical(l1,_g1,r1);
			}
			break;
		default:
			return expr;
		}
	}
}
cosy.Optimizer.__name__ = true;
Object.assign(cosy.Optimizer.prototype, {
	__class__: cosy.Optimizer
});
cosy.Parser = class cosy_Parser {
	constructor(tokens) {
		this.current = 0;
		this.structNames = [];
		this.tokens = tokens;
	}
	parse() {
		let statements = [];
		while(!this.isAtEnd()) statements.push(this.declaration());
		return statements;
	}
	expression() {
		return this.assignment();
	}
	declaration() {
		try {
			if(this.match([cosy.TokenType.Struct])) {
				return this.structDeclaration();
			}
			let foreign = this.match([cosy.TokenType.Foreign]);
			if(this.match([cosy.TokenType.Fn])) {
				return this.func("function",foreign);
			}
			if(this.match([cosy.TokenType.Var])) {
				return this.varDeclaration(false,foreign);
			}
			if(this.match([cosy.TokenType.Mut])) {
				return this.varDeclaration(true,foreign);
			}
			return this.statement();
		} catch( _g ) {
			if(((haxe.Exception.caught(_g).unwrap()) instanceof cosy._Parser.ParseError)) {
				this.synchronize();
				return null;
			} else {
				throw _g;
			}
		}
	}
	statement() {
		if(this.match([cosy.TokenType.For])) {
			return this.forStatement();
		}
		if(this.match([cosy.TokenType.If])) {
			return this.ifStatement();
		}
		if(this.match([cosy.TokenType.Print])) {
			return this.printStatement();
		}
		if(this.match([cosy.TokenType.Return])) {
			return this.returnStatement();
		}
		if(this.match([cosy.TokenType.Break])) {
			return cosy.Stmt.Break(this.previous());
		}
		if(this.match([cosy.TokenType.Continue])) {
			return cosy.Stmt.Continue(this.previous());
		}
		if(this.match([cosy.TokenType.LeftBrace])) {
			return cosy.Stmt.Block(this.block());
		}
		return this.expressionStatement();
	}
	forStatement() {
		if(this.checkUntil(cosy.TokenType.DotDot,cosy.TokenType.LeftBrace)) {
			let keyword = this.previous();
			let name = null;
			if(this.check(cosy.TokenType.Identifier)) {
				name = this.consume(cosy.TokenType.Identifier,"Expect variable name.");
				if(StringTools.startsWith(name.lexeme,"_")) {
					this.error(name,"Loop counters cannot be marked as unused. Use `for min...max` syntax instead.");
				}
				this.consume(cosy.TokenType.In,"Expect \"in\" after for loop identifier.");
			}
			let from = this.expression();
			this.consume(cosy.TokenType.DotDot,"Expect \"..\" between from and to numbers.");
			let to = this.expression();
			this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" before loop body.");
			return cosy.Stmt.For(keyword,name,from,to,this.block());
		} else if(this.checkUntil(cosy.TokenType.In,cosy.TokenType.LeftBrace)) {
			let name = this.consume(cosy.TokenType.Identifier,"Expect variable name.");
			this.consume(cosy.TokenType.In,"Expect \"in\" after for loop identifier.");
			let array = this.expression();
			this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" before loop body.");
			return cosy.Stmt.ForArray(name,array,this.block());
		} else {
			let condition = this.check(cosy.TokenType.LeftBrace) ? null : this.expression();
			this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" before loop body.");
			return cosy.Stmt.ForCondition(condition,this.block());
		}
	}
	ifStatement() {
		return cosy.Stmt.If(this.expression(),this.statement(),this.match([cosy.TokenType.Else]) ? this.statement() : null);
	}
	printStatement() {
		return cosy.Stmt.Print(this.previous(),this.expression());
	}
	returnStatement() {
		return cosy.Stmt.Return(this.previous(),this.match([cosy.TokenType.Underscore]) ? null : this.expression());
	}
	expressionStatement() {
		return cosy.Stmt.Expression(this.expression());
	}
	block() {
		let statements = [];
		while(!this.check(cosy.TokenType.RightBrace) && !this.isAtEnd()) statements.push(this.declaration());
		this.consume(cosy.TokenType.RightBrace,"Expect \"}\" after block.");
		return statements;
	}
	varDeclaration(mut,foreign) {
		let name = this.consume(cosy.TokenType.Identifier,"Expect variable name.");
		let type = this.paramType();
		let initializer = null;
		if(!foreign && this.match([cosy.TokenType.Equal])) {
			initializer = this.expression();
		}
		return cosy.Stmt.Var(name,type,initializer,mut,foreign);
	}
	structDeclaration() {
		let name = this.consume(cosy.TokenType.Identifier,"Expect class name");
		this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" before struct body.");
		let declarations = [];
		while(!this.check(cosy.TokenType.RightBrace) && !this.isAtEnd()) if(this.match([cosy.TokenType.Var])) {
			declarations.push(this.varDeclaration(false,false));
		} else if(this.match([cosy.TokenType.Mut])) {
			declarations.push(this.varDeclaration(true,false));
		} else {
			cosy.Cosy.error(cosy.ErrorDataType.Token(this.tokens[this.current]),"Structs can only contain variable definitions.");
			break;
		}
		this.structNames.push(name.lexeme);
		this.consume(cosy.TokenType.RightBrace,"Expect \"}\" after struct body.");
		return cosy.Stmt.Struct(name,declarations);
	}
	func(kind,foreign) {
		let name = this.consume(cosy.TokenType.Identifier,"Expect " + kind + " name.");
		let functionExpr = this.funcBody(kind,foreign);
		if(functionExpr._hx_index == 13) {
			return cosy.Stmt.Function(name,functionExpr.params,functionExpr.body,functionExpr.returnType,foreign);
		} else {
			throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Invalid function declaration."));
		}
	}
	paramType() {
		if(this.match([cosy.TokenType.BooleanType])) {
			return cosy.VariableType.Boolean;
		} else if(this.match([cosy.TokenType.NumberType])) {
			return cosy.VariableType.Number;
		} else if(this.match([cosy.TokenType.StringType])) {
			return cosy.VariableType.Text;
		} else if(this.match([cosy.TokenType.VoidType])) {
			return cosy.VariableType.Void;
		} else if(this.match([cosy.TokenType.FunctionType])) {
			this.consume(cosy.TokenType.LeftParen,"Expect \"(\" after Fun.");
			let funcParamTypes = [];
			while(!this.check(cosy.TokenType.RightParen)) {
				funcParamTypes.push(this.paramType());
				if(!this.match([cosy.TokenType.Comma])) {
					break;
				}
			}
			this.consume(cosy.TokenType.RightParen,"Expect \")\" after parameters.");
			let returnType = this.paramType();
			if(returnType._hx_index == 0) {
				returnType = cosy.VariableType.Void;
			}
			return cosy.VariableType.Function(funcParamTypes,returnType);
		} else if(this.match([cosy.TokenType.ArrayType])) {
			return cosy.VariableType.Array(this.paramType());
		} else if(this.check(cosy.TokenType.Identifier) && this.structNames.indexOf(this.peek().lexeme) != -1) {
			return cosy.VariableType.NamedStruct(this.advance().lexeme);
		} else {
			return cosy.VariableType.Unknown;
		}
	}
	funcBody(kind,foreign) {
		this.consume(cosy.TokenType.LeftParen,"Expect \"(\" after " + kind + " name.");
		let params = [];
		if(!this.check(cosy.TokenType.RightParen)) {
			while(true) {
				if(params.length >= 255) {
					this.error(this.peek(),"Cannot have more than 255 parameters.");
				}
				let mutable = this.match([cosy.TokenType.Mut]);
				let name = this.consume(cosy.TokenType.Identifier,"Expect parameter name.");
				let type = this.paramType();
				if(mutable) {
					if(type._hx_index != 9 && type._hx_index != 0) {
						this.error(name,"Only struct parameters can be marked as `mut`.");
					}
					type = cosy.VariableType.Mutable(type);
				}
				params.push({ name : name, type : type});
				if(!this.match([cosy.TokenType.Comma])) {
					break;
				}
			}
		}
		this.consume(cosy.TokenType.RightParen,"Expect \")\" after parameters.");
		let returnType = this.paramType();
		if(foreign) {
			return cosy.Expr.AnonFunction(params,[],returnType);
		}
		this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" before " + kind + " body");
		return cosy.Expr.AnonFunction(params,this.block(),returnType);
	}
	assignment() {
		let expr = this.or();
		if(this.match([cosy.TokenType.Equal,cosy.TokenType.PlusEqual,cosy.TokenType.MinusEqual,cosy.TokenType.SlashEqual,cosy.TokenType.StarEqual])) {
			let equals = this.previous();
			let value = this.assignment();
			switch(expr._hx_index) {
			case 4:
				return cosy.Expr.Set(expr.obj,expr.name,value);
			case 12:
				return cosy.Expr.Assign(expr.name,equals,value);
			default:
			}
			this.error(equals,"Invalid assignment target.");
		}
		return expr;
	}
	or() {
		let expr = this.and();
		while(this.match([cosy.TokenType.Or])) expr = cosy.Expr.Logical(expr,this.previous(),this.and());
		return expr;
	}
	and() {
		let expr = this.equality();
		while(this.match([cosy.TokenType.And])) expr = cosy.Expr.Logical(expr,this.previous(),this.equality());
		return expr;
	}
	equality() {
		let expr = this.comparison();
		while(this.match([cosy.TokenType.BangEqual,cosy.TokenType.EqualEqual])) expr = cosy.Expr.Binary(expr,this.previous(),this.comparison());
		return expr;
	}
	comparison() {
		let expr = this.addition();
		while(this.match([cosy.TokenType.Greater,cosy.TokenType.GreaterEqual,cosy.TokenType.Less,cosy.TokenType.LessEqual])) expr = cosy.Expr.Binary(expr,this.previous(),this.addition());
		return expr;
	}
	addition() {
		let expr = this.multiplication();
		while(this.match([cosy.TokenType.Minus,cosy.TokenType.Plus])) expr = cosy.Expr.Binary(expr,this.previous(),this.multiplication());
		return expr;
	}
	multiplication() {
		let expr = this.unary();
		while(this.match([cosy.TokenType.Star,cosy.TokenType.Slash])) expr = cosy.Expr.Binary(expr,this.previous(),this.multiplication());
		return expr;
	}
	unary() {
		if(this.match([cosy.TokenType.Bang,cosy.TokenType.Minus])) {
			return cosy.Expr.Unary(this.previous(),this.unary());
		} else {
			return this.call();
		}
	}
	call() {
		let expr = this.primary();
		while(true) if(this.match([cosy.TokenType.LeftParen])) {
			expr = this.finishCall(expr);
		} else if(this.match([cosy.TokenType.Dot])) {
			expr = cosy.Expr.Get(expr,this.consume(cosy.TokenType.Identifier,"Expect property name after \".\"."));
		} else {
			break;
		}
		return expr;
	}
	finishCall(callee) {
		let args = [];
		if(!this.check(cosy.TokenType.RightParen)) {
			while(true) {
				if(args.length >= 255) {
					this.error(this.peek(),"Cannot have more than 255 arguments");
				}
				args.push(this.expression());
				if(!this.match([cosy.TokenType.Comma])) {
					break;
				}
			}
		}
		return cosy.Expr.Call(callee,this.consume(cosy.TokenType.RightParen,"Expect \")\" after arguments."),args);
	}
	primary() {
		if(this.match([cosy.TokenType.False])) {
			return cosy.Expr.Literal(false);
		}
		if(this.match([cosy.TokenType.True])) {
			return cosy.Expr.Literal(true);
		}
		if(this.match([cosy.TokenType.Number,cosy.TokenType.String])) {
			return cosy.Expr.Literal(this.previous().literal);
		}
		if(this.match([cosy.TokenType.Fn])) {
			return this.funcBody("function",false);
		}
		if(this.match([cosy.TokenType.Identifier])) {
			return this.identifier();
		}
		if(this.match([cosy.TokenType.Mut])) {
			return cosy.Expr.MutArgument(this.previous(),this.consume(cosy.TokenType.Identifier,"Expect variable name after \"mut\"."));
		}
		if(this.match([cosy.TokenType.LeftParen])) {
			let expr = this.expression();
			this.consume(cosy.TokenType.RightParen,"Expect \")\" after expression.");
			return cosy.Expr.Grouping(expr);
		}
		if(this.match([cosy.TokenType.LeftBracket])) {
			return this.arrayLiteral();
		}
		throw haxe.Exception.thrown(this.error(this.peek(),"Expect expression."));
	}
	arrayLiteral() {
		let keyword = this.previous();
		let exprs = [];
		while(!this.check(cosy.TokenType.RightBracket) && !this.isAtEnd()) {
			exprs.push(this.expression());
			if(!this.check(cosy.TokenType.RightBracket)) {
				this.consume(cosy.TokenType.Comma,"Expect \",\" between array values.");
			}
		}
		this.consume(cosy.TokenType.RightBracket,"Expect \"]\" after array literal.");
		return cosy.Expr.ArrayLiteral(keyword,exprs);
	}
	identifier() {
		let variable = this.previous();
		if(this.check(cosy.TokenType.LeftBrace) && this.structNames.indexOf(variable.lexeme) != -1) {
			this.consume(cosy.TokenType.LeftBrace,"Expect \"{\" after struct name.");
			let decls = [];
			while(!this.match([cosy.TokenType.RightBrace]) && !this.isAtEnd()) {
				decls.push(this.assignment());
				if(!this.check(cosy.TokenType.RightBrace)) {
					this.consume(cosy.TokenType.Comma,"Expect \",\" between variable initializers.");
				}
			}
			return cosy.Expr.StructInit(variable,decls);
		} else {
			return cosy.Expr.Variable(variable);
		}
	}
	consume(type,message) {
		if(this.check(type)) {
			return this.advance();
		}
		throw haxe.Exception.thrown(this.error(this.peek(),message));
	}
	match(types) {
		let _g = 0;
		while(_g < types.length) if(this.check(types[_g++])) {
			this.advance();
			return true;
		}
		return false;
	}
	check(type) {
		if(this.isAtEnd()) {
			return false;
		}
		return this.peek().type == type;
	}
	checkUntil(type,until) {
		let cur = this.current;
		while(true) {
			if(this.tokens[cur].type == type) {
				return true;
			}
			++cur;
			if(!(this.tokens[cur].type != until && this.tokens[cur].type != cosy.TokenType.Eof)) {
				break;
			}
		}
		return false;
	}
	advance() {
		if(!this.isAtEnd()) {
			this.current++;
		}
		return this.previous();
	}
	isAtEnd() {
		return this.peek().type == cosy.TokenType.Eof;
	}
	peek() {
		return this.tokens[this.current];
	}
	previous() {
		return this.tokens[this.current - 1];
	}
	error(token,message) {
		cosy.Cosy.error(cosy.ErrorDataType.Token(token),message);
		return new cosy._Parser.ParseError();
	}
	synchronize() {
		this.advance();
		while(!this.isAtEnd()) switch(this.peek().type._hx_index) {
		case 30:case 31:case 34:case 35:case 36:case 38:case 41:case 42:case 43:case 45:
			return;
		default:
			this.advance();
		}
	}
}
cosy.Parser.__name__ = true;
Object.assign(cosy.Parser.prototype, {
	__class__: cosy.Parser
});
cosy._Parser = {};
cosy._Parser.ParseError = class cosy__$Parser_ParseError extends cosy.Error {
	constructor(message) {
		super(message);
	}
}
cosy._Parser.ParseError.__name__ = true;
cosy._Parser.ParseError.__super__ = cosy.Error;
Object.assign(cosy._Parser.ParseError.prototype, {
	__class__: cosy._Parser.ParseError
});
cosy.Resolver = class cosy_Resolver {
	constructor(interpreter) {
		this.currentStruct = cosy._Resolver.StructType.None;
		this.currentFunction = cosy._Resolver.FunctionType.None;
		this.scopes = [];
		this.interpreter = interpreter;
	}
	resolveStmts(stmts) {
		let returnToken = null;
		let _g = 0;
		while(_g < stmts.length) {
			let stmt = stmts[_g];
			++_g;
			switch(stmt._hx_index) {
			case 1:
				returnToken = stmt.keyword;
				break;
			case 2:
				returnToken = stmt.keyword;
				break;
			case 10:
				returnToken = stmt.keyword;
				break;
			default:
				if(returnToken != null) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(returnToken),"Unreachable code after return statement.");
					returnToken = null;
				}
			}
			this.resolveStmt(stmt);
		}
	}
	resolveStmt(stmt) {
		while(true) {
			switch(stmt._hx_index) {
			case 0:
				this.beginScope();
				this.resolveStmts(stmt.statements);
				this.endScope();
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				this.resolveExpr(stmt.e);
				break;
			case 4:
				let _g = stmt.body;
				let _g1 = stmt.name;
				this.resolveExpr(stmt.from);
				this.resolveExpr(stmt.to);
				this.beginScope();
				if(_g1 != null) {
					this.declare(_g1);
					this.define(_g1);
				}
				if(_g.length == 0) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(stmt.keyword),"Loop body is empty.");
				}
				this.resolveStmts(_g);
				this.endScope();
				break;
			case 5:
				let _g2 = stmt.body;
				let _g3 = stmt.name;
				this.resolveExpr(stmt.array);
				this.beginScope();
				this.declare(_g3);
				this.define(_g3);
				if(_g2.length == 0) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g3),"Loop body is empty.");
				}
				this.resolveStmts(_g2);
				this.endScope();
				break;
			case 6:
				let _g4 = stmt.cond;
				if(_g4 != null) {
					this.resolveExpr(_g4);
				}
				this.beginScope();
				this.resolveStmts(stmt.body);
				this.endScope();
				break;
			case 7:
				let _g5 = stmt.foreign;
				let _g6 = stmt.name;
				if(_g5 && !Object.prototype.hasOwnProperty.call(cosy.Cosy.foreignFunctions.h,_g6.lexeme)) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g6),"Foreign function not set.");
				}
				this.declare(_g6);
				this.define(_g6);
				this.resolveFunction(_g6,stmt.params,stmt.body,cosy._Resolver.FunctionType.Function,_g5);
				break;
			case 8:
				let _g7 = stmt.el;
				this.resolveExpr(stmt.cond);
				this.resolveStmt(stmt.then);
				if(_g7 != null) {
					stmt = _g7;
					continue;
				}
				break;
			case 9:
				this.resolveExpr(stmt.e);
				break;
			case 10:
				let _g8 = stmt.value;
				let _g9 = stmt.keyword;
				if(this.currentFunction == cosy._Resolver.FunctionType.None) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g9),"Cannot return from top-level code.");
				}
				if(_g8 != null) {
					if(this.currentFunction == cosy._Resolver.FunctionType.Initializer) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g9),"Cannot return value from an initializer.");
					}
					this.resolveExpr(_g8);
				}
				break;
			case 11:
				let _g10 = stmt.name;
				this.declare(_g10);
				this.define(_g10);
				this.currentStruct = cosy._Resolver.StructType.Struct;
				this.beginScope();
				this.resolveStmts(stmt.declarations);
				this.endScope();
				this.currentStruct = cosy._Resolver.StructType.None;
				break;
			case 12:
				let _g11 = stmt.mut;
				let _g12 = stmt.init;
				let _g13 = stmt.name;
				if(stmt.foreign && !Object.prototype.hasOwnProperty.call(cosy.Cosy.foreignVariables.h,_g13.lexeme)) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g13),"Foreign variable not set.");
				}
				let member = this.currentStruct._hx_index == 1;
				this.declare(_g13,_g11,member);
				if(_g12 != null) {
					this.resolveExpr(_g12);
				}
				this.define(_g13,_g11,member);
				break;
			}
			return;
		}
	}
	resolveExpr(expr) {
		while(true) {
			switch(expr._hx_index) {
			case 0:
				let _g = expr.exprs;
				let _g1 = 0;
				while(_g1 < _g.length) this.resolveExpr(_g[_g1++]);
				break;
			case 1:
				let _g2 = expr.name;
				let variable = this.findInScopes(_g2);
				if(variable != null && !variable.mutable) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g2),"Cannot reassign non-mutable variable.");
				}
				this.resolveExpr(expr.value);
				this.resolveLocal(expr,_g2,false);
				break;
			case 2:
				this.resolveExpr(expr.left);
				expr = expr.right;
				continue;
			case 3:
				let _g3 = expr.$arguments;
				this.resolveExpr(expr.callee);
				let _g4 = 0;
				while(_g4 < _g3.length) this.resolveExpr(_g3[_g4++]);
				break;
			case 4:
				expr = expr.obj;
				continue;
			case 5:
				expr = expr.e;
				continue;
			case 6:
				break;
			case 7:
				this.resolveExpr(expr.left);
				expr = expr.right;
				continue;
			case 8:
				this.resolveLocal(expr,expr.name,true);
				break;
			case 9:
				let _g5 = expr.name;
				let _g6 = expr.obj;
				this.resolveExpr(expr.value);
				this.resolveExpr(_g6);
				switch(_g6._hx_index) {
				case 4:
					break;
				case 12:
					let variable1 = this.findInScopes(_g6.name);
					if(variable1 != null && !variable1.mutable) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g5),"Cannot reassign properties on non-mutable struct.");
					}
					break;
				default:
					console.log("src/cosy/Resolver.hx:151:",_g6);
					throw haxe.Exception.thrown("this is unexpected");
				}
				break;
			case 10:
				let _g7 = expr.decls;
				let _g8 = expr.name;
				let _g9 = 0;
				while(_g9 < _g7.length) {
					let decl = _g7[_g9];
					++_g9;
					if(decl._hx_index == 1) {
						this.resolveExpr(decl.value);
					}
				}
				this.resolveLocal(expr,_g8,true);
				break;
			case 11:
				expr = expr.right;
				continue;
			case 12:
				let _g10 = expr.name;
				let tmp;
				let this1 = this.scopes;
				if(Object.prototype.hasOwnProperty.call(this1[this1.length - 1].h,_g10.lexeme)) {
					let this1 = this.scopes;
					tmp = this1[this1.length - 1].h[_g10.lexeme].state._hx_index == 0;
				} else {
					tmp = false;
				}
				if(tmp) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g10),"Cannot read local variable in its own initializer");
				}
				if(StringTools.startsWith(_g10.lexeme,"_")) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g10),"Variables starting with _ are considered unused.");
				}
				this.resolveLocal(expr,_g10,true);
				break;
			case 13:
				this.resolveFunction(null,expr.params,expr.body,cosy._Resolver.FunctionType.Function,false);
				break;
			}
			return;
		}
	}
	resolveFunction(name,params,body,type,foreign) {
		let enclosingFunction = this.currentFunction;
		this.currentFunction = type;
		this.beginScope();
		let _g = 0;
		while(_g < params.length) {
			let param = params[_g];
			++_g;
			let mutable = param.type._hx_index == 10;
			this.declare(param.name,mutable);
			if(!foreign) {
				this.define(param.name,mutable);
			}
		}
		this.resolveStmts(body);
		this.endScope();
		this.currentFunction = enclosingFunction;
	}
	beginScope() {
		this.scopes.push(new haxe.ds.StringMap());
	}
	endScope() {
		let _g = haxe.ds.StringMap.kvIterator(this.scopes.pop().h);
		while(_g.hasNext()) {
			let variable = _g.next().value;
			if(StringTools.startsWith(variable.name.lexeme,"_")) {
				continue;
			}
			if(!variable.member && variable.state._hx_index == 1) {
				cosy.Cosy.error(cosy.ErrorDataType.Token(variable.name),"Local variable is not used.");
			}
		}
	}
	declare(name,mutable,member) {
		if(member == null) {
			member = false;
		}
		if(mutable == null) {
			mutable = false;
		}
		let this1 = this.scopes;
		let scope = this1[this1.length - 1];
		if(Object.prototype.hasOwnProperty.call(scope.h,name.lexeme)) {
			cosy.Cosy.error(cosy.ErrorDataType.Token(name),"Variable with this name already declared in this scope.");
		} else if(this.findInScopes(name) != null) {
			cosy.Cosy.error(cosy.ErrorDataType.Token(name),"Shadows existing variable.");
		}
		scope.h[name.lexeme] = { name : name, state : cosy._Resolver.VariableState.Declared, mutable : mutable, member : member};
	}
	define(name,mutable,member) {
		if(member == null) {
			member = false;
		}
		if(mutable == null) {
			mutable = false;
		}
		let this1 = this.scopes;
		this1[this1.length - 1].h[name.lexeme] = { name : name, state : cosy._Resolver.VariableState.Defined, mutable : mutable, member : member};
	}
	resolveLocal(expr,name,isRead) {
		let i = this.scopes.length - 1;
		while(i >= 0) {
			let scope = this.scopes[i];
			if(Object.prototype.hasOwnProperty.call(scope.h,name.lexeme)) {
				this.interpreter.resolve(expr,this.scopes.length - 1 - i);
				if(isRead) {
					scope.h[name.lexeme].state = cosy._Resolver.VariableState.Read;
				}
				return;
			}
			--i;
		}
		if(name.lexeme == "clock" || name.lexeme == "random") {
			return;
		}
		cosy.Cosy.error(cosy.ErrorDataType.Token(name),"Variable not declared in this scope.");
	}
	findInScopes(name) {
		let identifier = name.lexeme;
		let i = this.scopes.length - 1;
		while(i >= 0) {
			let scope = this.scopes[i];
			if(Object.prototype.hasOwnProperty.call(scope.h,identifier)) {
				return scope.h[identifier];
			}
			--i;
		}
		return null;
	}
}
cosy.Resolver.__name__ = true;
Object.assign(cosy.Resolver.prototype, {
	__class__: cosy.Resolver
});
cosy._Resolver = {};
cosy._Resolver.VariableState = $hxEnums["cosy._Resolver.VariableState"] = { __ename__ : true, __constructs__ : ["Declared","Defined","Read"]
	,Declared: {_hx_index:0,__enum__:"cosy._Resolver.VariableState",toString:$estr}
	,Defined: {_hx_index:1,__enum__:"cosy._Resolver.VariableState",toString:$estr}
	,Read: {_hx_index:2,__enum__:"cosy._Resolver.VariableState",toString:$estr}
};
cosy._Resolver.FunctionType = $hxEnums["cosy._Resolver.FunctionType"] = { __ename__ : true, __constructs__ : ["None","Method","Initializer","Function"]
	,None: {_hx_index:0,__enum__:"cosy._Resolver.FunctionType",toString:$estr}
	,Method: {_hx_index:1,__enum__:"cosy._Resolver.FunctionType",toString:$estr}
	,Initializer: {_hx_index:2,__enum__:"cosy._Resolver.FunctionType",toString:$estr}
	,Function: {_hx_index:3,__enum__:"cosy._Resolver.FunctionType",toString:$estr}
};
cosy._Resolver.StructType = $hxEnums["cosy._Resolver.StructType"] = { __ename__ : true, __constructs__ : ["None","Struct"]
	,None: {_hx_index:0,__enum__:"cosy._Resolver.StructType",toString:$estr}
	,Struct: {_hx_index:1,__enum__:"cosy._Resolver.StructType",toString:$estr}
};
cosy.Return = class cosy_Return extends cosy.Error {
	constructor(value) {
		super();
		this.value = value;
	}
}
cosy.Return.__name__ = true;
cosy.Return.__super__ = cosy.Error;
Object.assign(cosy.Return.prototype, {
	__class__: cosy.Return
});
cosy.RuntimeError = class cosy_RuntimeError extends cosy.Error {
	constructor(token,message) {
		super(message);
		this.token = token;
	}
}
cosy.RuntimeError.__name__ = true;
cosy.RuntimeError.__super__ = cosy.Error;
Object.assign(cosy.RuntimeError.prototype, {
	__class__: cosy.RuntimeError
});
cosy.TokenType = $hxEnums["cosy.TokenType"] = { __ename__ : true, __constructs__ : ["LeftParen","RightParen","LeftBrace","RightBrace","LeftBracket","RightBracket","Comma","Dot","DotDot","Underscore","Minus","MinusEqual","Plus","PlusEqual","Slash","SlashEqual","Star","StarEqual","Bang","BangEqual","Equal","EqualEqual","Greater","GreaterEqual","Less","LessEqual","Identifier","String","Number","And","Break","Continue","Else","False","Fn","For","Foreign","In","If","Mut","Or","Print","Return","Struct","True","Var","BooleanType","NumberType","StringType","VoidType","FunctionType","ArrayType","Eof"]
	,LeftParen: {_hx_index:0,__enum__:"cosy.TokenType",toString:$estr}
	,RightParen: {_hx_index:1,__enum__:"cosy.TokenType",toString:$estr}
	,LeftBrace: {_hx_index:2,__enum__:"cosy.TokenType",toString:$estr}
	,RightBrace: {_hx_index:3,__enum__:"cosy.TokenType",toString:$estr}
	,LeftBracket: {_hx_index:4,__enum__:"cosy.TokenType",toString:$estr}
	,RightBracket: {_hx_index:5,__enum__:"cosy.TokenType",toString:$estr}
	,Comma: {_hx_index:6,__enum__:"cosy.TokenType",toString:$estr}
	,Dot: {_hx_index:7,__enum__:"cosy.TokenType",toString:$estr}
	,DotDot: {_hx_index:8,__enum__:"cosy.TokenType",toString:$estr}
	,Underscore: {_hx_index:9,__enum__:"cosy.TokenType",toString:$estr}
	,Minus: {_hx_index:10,__enum__:"cosy.TokenType",toString:$estr}
	,MinusEqual: {_hx_index:11,__enum__:"cosy.TokenType",toString:$estr}
	,Plus: {_hx_index:12,__enum__:"cosy.TokenType",toString:$estr}
	,PlusEqual: {_hx_index:13,__enum__:"cosy.TokenType",toString:$estr}
	,Slash: {_hx_index:14,__enum__:"cosy.TokenType",toString:$estr}
	,SlashEqual: {_hx_index:15,__enum__:"cosy.TokenType",toString:$estr}
	,Star: {_hx_index:16,__enum__:"cosy.TokenType",toString:$estr}
	,StarEqual: {_hx_index:17,__enum__:"cosy.TokenType",toString:$estr}
	,Bang: {_hx_index:18,__enum__:"cosy.TokenType",toString:$estr}
	,BangEqual: {_hx_index:19,__enum__:"cosy.TokenType",toString:$estr}
	,Equal: {_hx_index:20,__enum__:"cosy.TokenType",toString:$estr}
	,EqualEqual: {_hx_index:21,__enum__:"cosy.TokenType",toString:$estr}
	,Greater: {_hx_index:22,__enum__:"cosy.TokenType",toString:$estr}
	,GreaterEqual: {_hx_index:23,__enum__:"cosy.TokenType",toString:$estr}
	,Less: {_hx_index:24,__enum__:"cosy.TokenType",toString:$estr}
	,LessEqual: {_hx_index:25,__enum__:"cosy.TokenType",toString:$estr}
	,Identifier: {_hx_index:26,__enum__:"cosy.TokenType",toString:$estr}
	,String: {_hx_index:27,__enum__:"cosy.TokenType",toString:$estr}
	,Number: {_hx_index:28,__enum__:"cosy.TokenType",toString:$estr}
	,And: {_hx_index:29,__enum__:"cosy.TokenType",toString:$estr}
	,Break: {_hx_index:30,__enum__:"cosy.TokenType",toString:$estr}
	,Continue: {_hx_index:31,__enum__:"cosy.TokenType",toString:$estr}
	,Else: {_hx_index:32,__enum__:"cosy.TokenType",toString:$estr}
	,False: {_hx_index:33,__enum__:"cosy.TokenType",toString:$estr}
	,Fn: {_hx_index:34,__enum__:"cosy.TokenType",toString:$estr}
	,For: {_hx_index:35,__enum__:"cosy.TokenType",toString:$estr}
	,Foreign: {_hx_index:36,__enum__:"cosy.TokenType",toString:$estr}
	,In: {_hx_index:37,__enum__:"cosy.TokenType",toString:$estr}
	,If: {_hx_index:38,__enum__:"cosy.TokenType",toString:$estr}
	,Mut: {_hx_index:39,__enum__:"cosy.TokenType",toString:$estr}
	,Or: {_hx_index:40,__enum__:"cosy.TokenType",toString:$estr}
	,Print: {_hx_index:41,__enum__:"cosy.TokenType",toString:$estr}
	,Return: {_hx_index:42,__enum__:"cosy.TokenType",toString:$estr}
	,Struct: {_hx_index:43,__enum__:"cosy.TokenType",toString:$estr}
	,True: {_hx_index:44,__enum__:"cosy.TokenType",toString:$estr}
	,Var: {_hx_index:45,__enum__:"cosy.TokenType",toString:$estr}
	,BooleanType: {_hx_index:46,__enum__:"cosy.TokenType",toString:$estr}
	,NumberType: {_hx_index:47,__enum__:"cosy.TokenType",toString:$estr}
	,StringType: {_hx_index:48,__enum__:"cosy.TokenType",toString:$estr}
	,VoidType: {_hx_index:49,__enum__:"cosy.TokenType",toString:$estr}
	,FunctionType: {_hx_index:50,__enum__:"cosy.TokenType",toString:$estr}
	,ArrayType: {_hx_index:51,__enum__:"cosy.TokenType",toString:$estr}
	,Eof: {_hx_index:52,__enum__:"cosy.TokenType",toString:$estr}
};
cosy.Scanner = class cosy_Scanner {
	constructor(source) {
		this.line = 1;
		this.current = 0;
		this.start = 0;
		this.tokens = [];
		this.source = source;
	}
	scanTokens() {
		while(!this.isAtEnd()) {
			this.start = this.current;
			this.scanToken();
		}
		this.tokens.push(new cosy.Token(cosy.TokenType.Eof,"",null,this.line));
		return this.tokens;
	}
	scanToken() {
		let c = this.advance();
		switch(c) {
		case 10:
			this.line++;
			break;
		case 9:case 13:case 32:
			break;
		case 33:
			this.addToken(this.match(61) ? cosy.TokenType.BangEqual : cosy.TokenType.Bang);
			break;
		case 39:
			this.string();
			break;
		case 40:
			this.addToken(cosy.TokenType.LeftParen);
			break;
		case 41:
			this.addToken(cosy.TokenType.RightParen);
			break;
		case 42:
			this.addToken(this.match(61) ? cosy.TokenType.StarEqual : cosy.TokenType.Star);
			break;
		case 43:
			this.addToken(this.match(61) ? cosy.TokenType.PlusEqual : cosy.TokenType.Plus);
			break;
		case 44:
			this.addToken(cosy.TokenType.Comma);
			break;
		case 45:
			this.addToken(this.match(61) ? cosy.TokenType.MinusEqual : cosy.TokenType.Minus);
			break;
		case 46:
			this.addToken(this.match(46) ? cosy.TokenType.DotDot : cosy.TokenType.Dot);
			break;
		case 47:
			if(this.match(47)) {
				while(this.peek() != 10 && !this.isAtEnd()) this.advance();
			} else {
				this.addToken(this.match(61) ? cosy.TokenType.SlashEqual : cosy.TokenType.Slash);
			}
			break;
		case 60:
			this.addToken(this.match(61) ? cosy.TokenType.LessEqual : cosy.TokenType.Less);
			break;
		case 61:
			this.addToken(this.match(61) ? cosy.TokenType.EqualEqual : cosy.TokenType.Equal);
			break;
		case 62:
			this.addToken(this.match(61) ? cosy.TokenType.GreaterEqual : cosy.TokenType.Greater);
			break;
		case 91:
			this.addToken(cosy.TokenType.LeftBracket);
			break;
		case 93:
			this.addToken(cosy.TokenType.RightBracket);
			break;
		case 95:
			if(!this.isAlpha(this.peek())) {
				this.addToken(cosy.TokenType.Underscore);
			} else if(this.isDigit(c)) {
				this.number();
			} else if(this.isAlpha(c)) {
				this.identifier();
			} else {
				cosy.Cosy.error(cosy.ErrorDataType.Line(this.line),"Unexpected character: " + String.fromCodePoint(c));
			}
			break;
		case 123:
			this.addToken(cosy.TokenType.LeftBrace);
			break;
		case 125:
			this.addToken(cosy.TokenType.RightBrace);
			break;
		default:
			if(this.isDigit(c)) {
				this.number();
			} else if(this.isAlpha(c)) {
				this.identifier();
			} else {
				cosy.Cosy.error(cosy.ErrorDataType.Line(this.line),"Unexpected character: " + String.fromCodePoint(c));
			}
		}
	}
	identifier() {
		while(this.isAlphaNumeric(this.peek())) this.advance();
		let _g = cosy.Scanner.keywords.h[this.source.substring(this.start,this.current)];
		this.addToken(_g == null ? cosy.TokenType.Identifier : _g);
	}
	string() {
		while((this.peek() != 39 || this.peekPrevious() == 92) && !this.isAtEnd()) {
			if(this.peek() == 10) {
				this.line++;
			}
			this.advance();
		}
		if(this.isAtEnd()) {
			cosy.Cosy.error(cosy.ErrorDataType.Line(this.line),"Unterminated string.");
			return;
		}
		this.advance();
		let value = this.source.substring(this.start + 1,this.current - 1);
		value = StringTools.replace(value,"\\n","\n");
		value = StringTools.replace(value,"\\'","'");
		this.addToken(cosy.TokenType.String,value);
	}
	number() {
		while(this.isDigit(this.peek())) this.advance();
		if(this.peek() == 46 && this.isDigit(this.peekNext())) {
			this.advance();
			while(this.isDigit(this.peek())) this.advance();
		}
		this.addToken(cosy.TokenType.Number,parseFloat(this.source.substring(this.start,this.current)));
	}
	isDigit(c) {
		if(c >= 48) {
			return c <= 57;
		} else {
			return false;
		}
	}
	isAlpha(c) {
		if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90)) {
			return c == 95;
		} else {
			return true;
		}
	}
	isAlphaNumeric(c) {
		if(!this.isAlpha(c)) {
			return this.isDigit(c);
		} else {
			return true;
		}
	}
	match(expected) {
		if(this.isAtEnd()) {
			return false;
		}
		if(HxOverrides.cca(this.source,this.current) != expected) {
			return false;
		}
		this.current++;
		return true;
	}
	peek() {
		if(this.isAtEnd()) {
			return 0;
		}
		return HxOverrides.cca(this.source,this.current);
	}
	peekNext() {
		if(this.current + 1 >= this.source.length) {
			return 0;
		}
		return HxOverrides.cca(this.source,this.current + 1);
	}
	peekPrevious() {
		if(this.current - 1 >= this.source.length) {
			return 0;
		}
		return HxOverrides.cca(this.source,this.current - 1);
	}
	advance() {
		this.current++;
		return HxOverrides.cca(this.source,this.current - 1);
	}
	addToken(type,literal) {
		this.tokens.push(new cosy.Token(type,this.source.substring(this.start,this.current),literal,this.line));
	}
	isAtEnd() {
		return this.current >= this.source.length;
	}
}
cosy.Scanner.__name__ = true;
Object.assign(cosy.Scanner.prototype, {
	__class__: cosy.Scanner
});
cosy.Stmt = $hxEnums["cosy.Stmt"] = { __ename__ : true, __constructs__ : ["Block","Break","Continue","Expression","For","ForArray","ForCondition","Function","If","Print","Return","Struct","Var"]
	,Block: ($_=function(statements) { return {_hx_index:0,statements:statements,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["statements"],$_)
	,Break: ($_=function(keyword) { return {_hx_index:1,keyword:keyword,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["keyword"],$_)
	,Continue: ($_=function(keyword) { return {_hx_index:2,keyword:keyword,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["keyword"],$_)
	,Expression: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["e"],$_)
	,For: ($_=function(keyword,name,from,to,body) { return {_hx_index:4,keyword:keyword,name:name,from:from,to:to,body:body,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["keyword","name","from","to","body"],$_)
	,ForArray: ($_=function(name,array,body) { return {_hx_index:5,name:name,array:array,body:body,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["name","array","body"],$_)
	,ForCondition: ($_=function(cond,body) { return {_hx_index:6,cond:cond,body:body,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["cond","body"],$_)
	,Function: ($_=function(name,params,body,returnType,foreign) { return {_hx_index:7,name:name,params:params,body:body,returnType:returnType,foreign:foreign,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["name","params","body","returnType","foreign"],$_)
	,If: ($_=function(cond,then,el) { return {_hx_index:8,cond:cond,then:then,el:el,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["cond","then","el"],$_)
	,Print: ($_=function(keyword,e) { return {_hx_index:9,keyword:keyword,e:e,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["keyword","e"],$_)
	,Return: ($_=function(keyword,value) { return {_hx_index:10,keyword:keyword,value:value,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["keyword","value"],$_)
	,Struct: ($_=function(name,declarations) { return {_hx_index:11,name:name,declarations:declarations,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["name","declarations"],$_)
	,Var: ($_=function(name,type,init,mut,foreign) { return {_hx_index:12,name:name,type:type,init:init,mut:mut,foreign:foreign,__enum__:"cosy.Stmt",toString:$estr}; },$_.__params__ = ["name","type","init","mut","foreign"],$_)
};
cosy.StructInstance = class cosy_StructInstance {
	constructor(name,fields) {
		this.structName = name;
		this.fields = fields;
	}
	clone() {
		let clonedFields = new haxe.ds.StringMap();
		let _g = haxe.ds.StringMap.kvIterator(this.fields.h);
		while(_g.hasNext()) {
			let _g1 = _g.next();
			let key = _g1.key;
			let value = _g1.value;
			if(((value) instanceof cosy.StructInstance)) {
				let v = value.clone();
				clonedFields.h[key] = v;
			} else {
				clonedFields.h[key] = value;
			}
		}
		return new cosy.StructInstance(this.structName,clonedFields);
	}
	get(name) {
		if(Object.prototype.hasOwnProperty.call(this.fields.h,name.lexeme)) {
			return this.fields.h[name.lexeme];
		}
		throw haxe.Exception.thrown(new cosy.RuntimeError(name,"Undefined property \"" + name.lexeme + "\"."));
	}
	set(name,value) {
		if(!Object.prototype.hasOwnProperty.call(this.fields.h,name.lexeme)) {
			cosy.Cosy.error(cosy.ErrorDataType.Token(name),"" + name.lexeme + " is not a property of " + name.lexeme);
			return;
		}
		this.fields.h[name.lexeme] = value;
	}
	toString() {
		let formatValue = function(value) {
			if(typeof(value) == "string") {
				return "\"" + (value == null ? "null" : Std.string(value)) + "\"";
			} else {
				return "" + (value == null ? "null" : Std.string(value));
			}
		};
		let _g = [];
		let _g1 = haxe.ds.StringMap.kvIterator(this.fields.h);
		while(_g1.hasNext()) {
			let _g2 = _g1.next();
			_g.push("" + _g2.key + " = " + formatValue(_g2.value));
		}
		_g.sort(function(a,b) {
			if(a < b) {
				return -1;
			}
			if(b < a) {
				return 1;
			}
			return 0;
		});
		return "" + this.structName.lexeme + " instance { " + _g.join(", ") + " }";
	}
}
cosy.StructInstance.__name__ = true;
Object.assign(cosy.StructInstance.prototype, {
	__class__: cosy.StructInstance
});
cosy.Token = class cosy_Token {
	constructor(type,lexeme,literal,line) {
		this.type = type;
		this.lexeme = lexeme;
		this.literal = literal;
		this.line = line;
	}
	toString() {
		return "Token { type: " + Std.string(this.type) + ", lexeme: \"" + this.lexeme + "\"" + (this.literal != null ? ", literal: " + (this.literal == null ? "null" : Std.string(this.literal)) : "") + " }";
	}
}
cosy.Token.__name__ = true;
Object.assign(cosy.Token.prototype, {
	__class__: cosy.Token
});
cosy.VariableType = $hxEnums["cosy.VariableType"] = { __ename__ : true, __constructs__ : ["Unknown","Void","Boolean","Number","Text","Instance","Function","Array","Struct","NamedStruct","Mutable"]
	,Unknown: {_hx_index:0,__enum__:"cosy.VariableType",toString:$estr}
	,Void: {_hx_index:1,__enum__:"cosy.VariableType",toString:$estr}
	,Boolean: {_hx_index:2,__enum__:"cosy.VariableType",toString:$estr}
	,Number: {_hx_index:3,__enum__:"cosy.VariableType",toString:$estr}
	,Text: {_hx_index:4,__enum__:"cosy.VariableType",toString:$estr}
	,Instance: {_hx_index:5,__enum__:"cosy.VariableType",toString:$estr}
	,Function: ($_=function(paramTypes,returnType) { return {_hx_index:6,paramTypes:paramTypes,returnType:returnType,__enum__:"cosy.VariableType",toString:$estr}; },$_.__params__ = ["paramTypes","returnType"],$_)
	,Array: ($_=function(type) { return {_hx_index:7,type:type,__enum__:"cosy.VariableType",toString:$estr}; },$_.__params__ = ["type"],$_)
	,Struct: ($_=function(variables) { return {_hx_index:8,variables:variables,__enum__:"cosy.VariableType",toString:$estr}; },$_.__params__ = ["variables"],$_)
	,NamedStruct: ($_=function(name) { return {_hx_index:9,name:name,__enum__:"cosy.VariableType",toString:$estr}; },$_.__params__ = ["name"],$_)
	,Mutable: ($_=function(type) { return {_hx_index:10,type:type,__enum__:"cosy.VariableType",toString:$estr}; },$_.__params__ = ["type"],$_)
};
cosy.Typer = class cosy_Typer {
	constructor() {
		this.inferredReturnType = cosy.VariableType.Void;
		this.typedReturnType = cosy.VariableType.Unknown;
		this.variableTypes = new haxe.ds.StringMap();
		this.structsMeta = new haxe.ds.StringMap();
		this.variableTypes.h["clock"] = cosy.VariableType.Function([],cosy.VariableType.Number);
		this.variableTypes.h["random"] = cosy.VariableType.Function([],cosy.VariableType.Number);
	}
	typeStmts(stmts) {
		let _g = 0;
		while(_g < stmts.length) this.typeStmt(stmts[_g++]);
	}
	typeStmt(stmt) {
		while(true) {
			switch(stmt._hx_index) {
			case 0:
				this.typeStmts(stmt.statements);
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				this.typeExpr(stmt.e);
				break;
			case 4:
				let _g = stmt.body;
				let _g1 = stmt.to;
				let _g2 = stmt.name;
				let _g3 = stmt.keyword;
				switch(this.typeExpr(stmt.from)._hx_index) {
				case 0:
					cosy.Cosy.warning(cosy.ErrorDataType.Token(_g3),"\"From\" clause has type Unknown");
					break;
				case 3:
					break;
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g3),"\"From\" clause must evaluate to a number");
				}
				switch(this.typeExpr(_g1)._hx_index) {
				case 0:
					cosy.Cosy.warning(cosy.ErrorDataType.Token(_g3),"\"To\" clause has type Unknown");
					break;
				case 3:
					break;
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g3),"\"To\" clause must evaluate to a number");
				}
				if(_g2 != null) {
					this.variableTypes.h[_g2.lexeme] = cosy.VariableType.Number;
				}
				this.typeStmts(_g);
				break;
			case 5:
				let _g4 = stmt.body;
				let _g5 = stmt.name;
				let arrayType = this.typeExpr(stmt.array);
				switch(arrayType._hx_index) {
				case 0:
					this.variableTypes.h[_g5.lexeme] = cosy.VariableType.Unknown;
					break;
				case 7:
					this.variableTypes.h[_g5.lexeme] = arrayType.type;
					break;
				case 10:
					let _g6 = arrayType.type;
					if(_g6._hx_index == 7) {
						this.variableTypes.h[_g5.lexeme] = _g6.type;
					} else {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g5),"Can only loop over value of type array.");
					}
					break;
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g5),"Can only loop over value of type array.");
				}
				this.typeStmts(_g4);
				break;
			case 6:
				this.typeStmts(stmt.body);
				break;
			case 7:
				this.handleFunc(stmt.name,stmt.params,stmt.body,stmt.returnType);
				break;
			case 8:
				let _g7 = stmt.el;
				this.typeStmt(stmt.then);
				if(_g7 != null) {
					stmt = _g7;
					continue;
				}
				break;
			case 9:
				if(this.typeExpr(stmt.e)._hx_index == 1) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(stmt.keyword),"Cannot print values of type void.");
				}
				break;
			case 10:
				let _g8 = stmt.value;
				if(_g8 != null) {
					this.inferredReturnType = this.typeExpr(_g8);
					if(!this.matchType(this.inferredReturnType,this.typedReturnType)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(stmt.keyword),"Function expected to return " + this.formatType(this.typedReturnType) + " but got " + this.formatType(this.inferredReturnType));
					}
				} else {
					this.inferredReturnType = cosy.VariableType.Void;
				}
				break;
			case 11:
				let _g9 = stmt.declarations;
				let _g10 = stmt.name;
				let structMeta = { members : new haxe.ds.StringMap()};
				let decls = new haxe.ds.StringMap();
				let _g11 = 0;
				while(_g11 < _g9.length) {
					let decl = _g9[_g11];
					++_g11;
					if(decl._hx_index == 12) {
						let _g = decl.mut;
						let _g1 = decl.init;
						let _g2 = decl.name;
						structMeta.members.h[_g2.lexeme] = { mutable : _g, initialized : _g1 != null};
						let computedType = this.typeVar(_g2,decl.type,_g1);
						if(_g) {
							computedType = cosy.VariableType.Mutable(computedType);
						}
						decls.h[_g2.lexeme] = computedType;
					} else {
						throw haxe.Exception.thrown("structs can only have var and mut");
					}
				}
				this.structsMeta.h[_g10.lexeme] = structMeta;
				this.variableTypes.h[_g10.lexeme] = cosy.VariableType.Struct(decls);
				break;
			case 12:
				let _g12 = stmt.name;
				let computedType = this.typeVar(_g12,stmt.type,stmt.init);
				if(stmt.mut) {
					computedType = cosy.VariableType.Mutable(computedType);
				}
				this.variableTypes.h[_g12.lexeme] = computedType;
				break;
			}
			return;
		}
	}
	typeVar(name,type,init) {
		let initType = init != null ? this.typeExpr(init) : cosy.VariableType.Unknown;
		if(initType._hx_index == 1) {
			cosy.Cosy.error(cosy.ErrorDataType.Token(name),"Cannot assign Void to a variable");
		}
		if(init != null && !this.matchType(initType,type)) {
			cosy.Cosy.error(cosy.ErrorDataType.Token(name),"Expected variable to have type " + this.formatType(type) + " but got " + this.formatType(initType) + ".");
		}
		if(type._hx_index != 0) {
			return type;
		} else {
			return initType;
		}
	}
	typeExpr(expr) {
		let ret;
		switch(expr._hx_index) {
		case 0:
			let _g = expr.exprs;
			let _g1 = expr.keyword;
			let arrayType = cosy.VariableType.Unknown;
			let _g2 = 0;
			let _g3 = _g.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let elemType = this.typeExpr(_g[i]);
				if(elemType._hx_index != 0) {
					if(arrayType._hx_index == 0) {
						arrayType = elemType;
					} else if(!this.matchType(elemType,arrayType)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g1),"Array values expected to be " + this.formatType(arrayType) + " but got " + this.formatType(elemType) + " at index " + i + ".");
					}
				}
			}
			return cosy.VariableType.Array(arrayType);
		case 1:
			let _g4 = expr.name;
			let assigningType = this.typeExpr(expr.value);
			let varType = this.variableTypes.h[_g4.lexeme];
			if((varType == null ? false : varType._hx_index == 0) || (varType == null ? false : varType._hx_index == 10 && varType.type._hx_index == 0)) {
				this.variableTypes.h[_g4.lexeme] = assigningType;
			} else if(!this.matchType(varType,assigningType)) {
				cosy.Cosy.error(cosy.ErrorDataType.Token(_g4),"Cannot assign " + this.formatType(assigningType) + " to " + this.formatType(varType,false));
			}
			return assigningType;
		case 2:
			let _g5 = expr.right;
			let _g6 = expr.left;
			switch(expr.op.type._hx_index) {
			case 12:
				let leftType = this.typeExpr(_g6);
				let rightType = this.typeExpr(_g5);
				if(leftType._hx_index == 4 || rightType._hx_index == 4) {
					return cosy.VariableType.Text;
				}
				if(leftType._hx_index == 3 || rightType._hx_index == 3) {
					return cosy.VariableType.Number;
				}
				ret = cosy.VariableType.Unknown;
				break;
			case 10:case 14:case 16:
				ret = cosy.VariableType.Number;
				break;
			case 18:case 19:case 20:case 21:case 22:case 23:case 24:case 25:
				ret = cosy.VariableType.Boolean;
				break;
			default:
				throw haxe.Exception.thrown("should never happen");
			}
			break;
		case 3:
			let _g7 = expr.$arguments;
			let _g8 = expr.paren;
			let calleeType = this.typeExpr(expr.callee);
			if(calleeType._hx_index == 10) {
				calleeType = calleeType.type;
			}
			let type = cosy.VariableType.Unknown;
			switch(calleeType._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 5:
				break;
			case 6:
				let _g9 = calleeType.paramTypes;
				type = calleeType.returnType;
				let _g10 = [];
				let _g11 = 0;
				while(_g11 < _g7.length) _g10.push(this.typeExpr(_g7[_g11++]));
				if(_g7.length != _g9.length) {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g8),"Expected " + _g9.length + " argument(s) but got " + _g7.length + ".");
				} else {
					let _g = 0;
					let _g1 = _g9.length;
					while(_g < _g1) {
						let i = _g++;
						if(_g10[i]._hx_index == 0) {
							cosy.Cosy.warning(cosy.ErrorDataType.Token(_g8),"Argument " + (i + 1) + " has type Unknown.");
						}
						if(!this.matchType(_g10[i],_g9[i])) {
							cosy.Cosy.error(cosy.ErrorDataType.Token(_g8),"Expected argument " + (i + 1) + " to be " + this.formatType(_g9[i]) + " but got " + this.formatType(_g10[i]) + ".");
						}
					}
				}
				break;
			default:
			}
			ret = type;
			break;
		case 4:
			let _g12 = expr.name;
			let objType = this.typeExpr(expr.obj);
			switch(objType._hx_index) {
			case 4:
				switch(_g12.lexeme) {
				case "charAt":
					return cosy.VariableType.Text;
				case "length":
					return cosy.VariableType.Number;
				case "split":
					return cosy.VariableType.Array(cosy.VariableType.Text);
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Unknown array property or function.");
					return cosy.VariableType.Void;
				}
				break;
			case 7:
				let _g13 = objType.type;
				switch(_g12.lexeme) {
				case "concat":
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Cannot call mutating method on immutable array.");
					return cosy.VariableType.Void;
				case "get":
					return cosy.VariableType.Function([cosy.VariableType.Number],_g13);
				case "length":
					return cosy.VariableType.Number;
				case "pop":
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Cannot call mutating method on immutable array.");
					return cosy.VariableType.Void;
				case "push":
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Cannot call mutating method on immutable array.");
					return cosy.VariableType.Void;
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Unknown array property or function.");
					return cosy.VariableType.Void;
				}
				break;
			case 8:
				let _g14 = objType.variables;
				if(Object.prototype.hasOwnProperty.call(_g14.h,_g12.lexeme)) {
					return _g14.h[_g12.lexeme];
				} else {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"No member named \"" + _g12.lexeme + "\" in struct of type " + this.formatType(objType,false));
					return cosy.VariableType.Unknown;
				}
				break;
			case 10:
				let _g15 = objType.type;
				switch(_g15._hx_index) {
				case 4:
					switch(_g12.lexeme) {
					case "charAt":
						return cosy.VariableType.Text;
					case "length":
						return cosy.VariableType.Number;
					case "split":
						return cosy.VariableType.Array(cosy.VariableType.Text);
					default:
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Unknown array property or function.");
						return cosy.VariableType.Void;
					}
					break;
				case 7:
					let _g16 = _g15.type;
					switch(_g12.lexeme) {
					case "concat":
						return cosy.VariableType.Function([cosy.VariableType.Array(_g16)],cosy.VariableType.Void);
					case "get":
						return cosy.VariableType.Function([cosy.VariableType.Number],_g16);
					case "length":
						return cosy.VariableType.Number;
					case "pop":
						return cosy.VariableType.Function([],_g16);
					case "push":
						return cosy.VariableType.Function([_g16],cosy.VariableType.Void);
					default:
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"Unknown array property or function.");
						return cosy.VariableType.Void;
					}
					break;
				case 8:
					let _g17 = _g15.variables;
					if(Object.prototype.hasOwnProperty.call(_g17.h,_g12.lexeme)) {
						return _g17.h[_g12.lexeme];
					} else {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g12),"No member named \"" + _g12.lexeme + "\" in struct of type " + this.formatType(objType,false));
						return cosy.VariableType.Unknown;
					}
					break;
				default:
					return cosy.VariableType.Unknown;
				}
				break;
			default:
				return cosy.VariableType.Unknown;
			}
			break;
		case 5:
			ret = this.typeExpr(expr.e);
			break;
		case 6:
			let _g18 = expr.v;
			ret = typeof(_g18) == "number" ? cosy.VariableType.Number : typeof(_g18) == "string" ? cosy.VariableType.Text : typeof(_g18) == "boolean" ? cosy.VariableType.Boolean : cosy.VariableType.Unknown;
			break;
		case 7:
			ret = cosy.VariableType.Boolean;
			break;
		case 8:
			let _g19 = expr.name;
			let type1 = this.variableTypes.h[_g19.lexeme];
			if(type1 == null) {
				cosy.Cosy.error(cosy.ErrorDataType.Token(_g19),"Only mutable structs can be passed as \"mut\". You passed " + this.formatType(type1,false) + ".");
			} else if(type1._hx_index == 10) {
				let _g = type1.type;
				switch(_g._hx_index) {
				case 8:
					break;
				case 10:
					if(_g.type._hx_index != 8) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g19),"Only mutable structs can be passed as \"mut\". You passed " + this.formatType(type1,false) + ".");
					}
					break;
				default:
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g19),"Only mutable structs can be passed as \"mut\". You passed " + this.formatType(type1,false) + ".");
				}
			} else {
				cosy.Cosy.error(cosy.ErrorDataType.Token(_g19),"Only mutable structs can be passed as \"mut\". You passed " + this.formatType(type1,false) + ".");
			}
			ret = type1;
			break;
		case 9:
			let _g20 = expr.value;
			let _g21 = expr.name;
			let objType1 = this.typeExpr(expr.obj);
			switch(objType1._hx_index) {
			case 9:
				objType1 = this.variableTypes.h[objType1.name];
				break;
			case 10:
				let _g22 = objType1.type;
				switch(_g22._hx_index) {
				case 8:
					objType1 = cosy.VariableType.Struct(_g22.variables);
					break;
				case 9:
					objType1 = this.variableTypes.h[_g22.name];
					break;
				default:
				}
				break;
			default:
			}
			if(objType1._hx_index == 8) {
				let _g = objType1.variables;
				if(Object.prototype.hasOwnProperty.call(_g.h,_g21.lexeme)) {
					let valueType = this.typeExpr(_g20);
					let structDeclType = _g.h[_g21.lexeme];
					let nonMutableStructDeclType = structDeclType == null ? structDeclType : structDeclType._hx_index == 10 ? structDeclType.type : structDeclType;
					if(!(structDeclType == null ? false : structDeclType._hx_index == 10)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g21),"Member is not mutable.");
					} else if(!this.matchType(valueType,nonMutableStructDeclType)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g21),"Expected value of type " + this.formatType(nonMutableStructDeclType) + " but got " + this.formatType(valueType));
					}
				} else {
					cosy.Cosy.error(cosy.ErrorDataType.Token(_g21),"No member named \"" + _g21.lexeme + "\" in struct of type " + this.formatType(objType1,false));
				}
			}
			ret = cosy.VariableType.Unknown;
			break;
		case 10:
			let _g23 = expr.decls;
			let _g24 = expr.name;
			let structType = this.variableTypes.h[_g24.lexeme];
			let assignedMembers = [];
			let structMembers;
			if(structType == null) {
				throw haxe.Exception.thrown("unexpected");
			} else if(structType._hx_index == 8) {
				structMembers = structType.variables;
			} else {
				throw haxe.Exception.thrown("unexpected");
			}
			let _g25 = 0;
			while(_g25 < _g23.length) {
				let decl = _g23[_g25];
				++_g25;
				if(decl._hx_index == 1) {
					let _g = decl.name;
					if(!Object.prototype.hasOwnProperty.call(structMembers.h,_g.lexeme)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g),"No member named \"" + _g.lexeme + "\" in struct " + _g24.lexeme);
						break;
					} else if(assignedMembers.indexOf(_g.lexeme) != -1) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g),"Member already assigned in initializer.");
						break;
					}
					let valueType = this.typeExpr(decl.value);
					let _g1 = structMembers.h[_g.lexeme];
					let memberType = _g1 == null ? _g1 : _g1._hx_index == 10 ? _g1.type : _g1;
					assignedMembers.push(_g.lexeme);
					if(!this.matchType(valueType,memberType)) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g),"Expected value to be of type " + this.formatType(memberType) + " but got " + this.formatType(valueType));
					}
				} else {
					throw haxe.Exception.thrown("unexpected");
				}
			}
			let _g26 = haxe.ds.StringMap.kvIterator(this.structsMeta.h[_g24.lexeme].members.h);
			while(_g26.hasNext()) {
				let _g = _g26.next();
				let memberName = _g.key;
				if(!_g.value.initialized) {
					if(assignedMembers.indexOf(memberName) == -1) {
						cosy.Cosy.error(cosy.ErrorDataType.Token(_g24),"Member \"" + memberName + "\" not initialized.");
					}
				}
			}
			ret = structType;
			break;
		case 11:
			switch(expr.op.type._hx_index) {
			case 10:
				ret = cosy.VariableType.Number;
				break;
			case 18:
				ret = cosy.VariableType.Boolean;
				break;
			default:
				throw haxe.Exception.thrown("should never happen");
			}
			break;
		case 12:
			let _g27 = expr.name;
			if(Object.prototype.hasOwnProperty.call(this.variableTypes.h,_g27.lexeme)) {
				return this.variableTypes.h[_g27.lexeme];
			} else {
				return cosy.VariableType.Unknown;
			}
			break;
		case 13:
			ret = this.handleFunc(null,expr.params,expr.body,expr.returnType);
			break;
		}
		return ret;
	}
	handleFunc(name,params,body,returnType) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < params.length) _g.push(params[_g1++].type);
		let _g2 = 0;
		while(_g2 < params.length) {
			let param = params[_g2];
			++_g2;
			this.variableTypes.h[param.name.lexeme] = param.type;
		}
		this.typedReturnType = returnType;
		this.inferredReturnType = cosy.VariableType.Void;
		this.typeStmts(body);
		let computedReturnType = returnType._hx_index == 0 ? this.inferredReturnType : returnType;
		if(name != null) {
			this.variableTypes.h[name.lexeme] = cosy.VariableType.Function(_g,computedReturnType);
		}
		return cosy.VariableType.Function(_g,computedReturnType);
	}
	matchType(valueType,expectedType) {
		while(true) switch(expectedType._hx_index) {
		case 0:
			return true;
		case 6:
			let _g = expectedType.returnType;
			let _g1 = expectedType.paramTypes;
			switch(valueType._hx_index) {
			case 6:
				let _g2 = valueType.returnType;
				let _g3 = valueType.paramTypes;
				if(_g3.length != _g1.length) {
					return false;
				}
				let _g4 = 0;
				while(_g4 < _g3.length) {
					let param1 = _g3[_g4++];
					let _g = 0;
					while(_g < _g1.length) if(!this.matchType(param1,_g1[_g++])) {
						return false;
					}
				}
				valueType = _g2;
				expectedType = _g;
				continue;
			case 10:
				valueType = valueType.type;
				continue;
			default:
				return valueType == expectedType;
			}
			break;
		case 7:
			let _g5 = expectedType.type;
			switch(valueType._hx_index) {
			case 7:
				let _g6 = valueType.type;
				if(_g6._hx_index == 0) {
					return true;
				} else {
					valueType = _g6;
					expectedType = _g5;
					continue;
				}
				break;
			case 10:
				valueType = valueType.type;
				continue;
			default:
				return valueType == expectedType;
			}
			break;
		case 8:
			let _g7 = expectedType.variables;
			switch(valueType._hx_index) {
			case 8:
				let _g8 = valueType.variables;
				let _g9 = haxe.ds.StringMap.kvIterator(_g8.h);
				while(_g9.hasNext()) {
					let _g = _g9.next();
					let key = _g.key;
					let value = _g.value;
					if(!Object.prototype.hasOwnProperty.call(_g7.h,key) || _g7.h[key] != value) {
						return false;
					}
				}
				let _g10 = haxe.ds.StringMap.kvIterator(_g7.h);
				while(_g10.hasNext()) {
					let _g = _g10.next();
					let key = _g.key;
					let value = _g.value;
					if(!Object.prototype.hasOwnProperty.call(_g8.h,key) || _g8.h[key] != value) {
						return false;
					}
				}
				return true;
			case 10:
				valueType = valueType.type;
				continue;
			default:
				return valueType == expectedType;
			}
			break;
		case 9:
			if(valueType._hx_index == 10) {
				valueType = valueType.type;
				continue;
			} else {
				expectedType = this.variableTypes.h[expectedType.name];
				continue;
			}
			break;
		case 10:
			if(valueType._hx_index == 10) {
				valueType = valueType.type;
				expectedType = expectedType.type;
				continue;
			} else {
				return valueType == expectedType;
			}
			break;
		default:
			if(valueType._hx_index == 10) {
				valueType = valueType.type;
				continue;
			} else {
				return valueType == expectedType;
			}
		}
	}
	formatType(type,showMutable) {
		if(showMutable == null) {
			showMutable = true;
		}
		while(true) switch(type._hx_index) {
		case 2:
			return "Bool";
		case 3:
			return "Num";
		case 4:
			return "Str";
		case 6:
			let _g = type.returnType;
			let _g1 = type.paramTypes;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < _g1.length) _g2.push(this.formatType(_g1[_g3++]));
			let returnStr = _g._hx_index == 1 ? "" : " -> " + this.formatType(_g);
			let funcStr = "Fn(" + _g2.join(", ") + ")" + returnStr;
			if(_g._hx_index == 1) {
				return funcStr;
			} else {
				return "(" + funcStr + ")";
			}
			break;
		case 7:
			let _g4 = type.type;
			if(_g4._hx_index == 0) {
				return "Array";
			} else {
				return "Array(" + this.formatType(_g4) + ")";
			}
			break;
		case 8:
			let _g5 = [];
			let _g6 = haxe.ds.StringMap.kvIterator(type.variables.h);
			while(_g6.hasNext()) {
				let _g = _g6.next();
				_g5.push("" + _g.key + " " + this.formatType(_g.value));
			}
			_g5.sort(function(a,b) {
				if(a < b) {
					return -1;
				}
				if(b < a) {
					return 1;
				}
				return 0;
			});
			return "Struct { " + _g5.join(", ") + " }";
		case 9:
			type = this.variableTypes.h[type.name];
			showMutable = true;
			continue;
		case 10:
			let _g7 = type.type;
			if(showMutable) {
				return "Mut(" + this.formatType(_g7) + ")";
			} else {
				type = _g7;
				showMutable = true;
				continue;
			}
			break;
		default:
			return "" + Std.string(type);
		}
	}
}
cosy.Typer.__name__ = true;
Object.assign(cosy.Typer.prototype, {
	__class__: cosy.Typer
});
var haxe = {};
haxe.IMap = class haxe_IMap {
}
haxe.IMap.__name__ = true;
haxe.Exception = class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe.Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe.Exception(value.message,null,value);
		} else {
			return new haxe.ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe.Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe.ValueException(value);
			return e;
		}
	}
}
haxe.Exception.__name__ = true;
haxe.Exception.__super__ = Error;
Object.assign(haxe.Exception.prototype, {
	__class__: haxe.Exception
});
haxe.ValueException = class haxe_ValueException extends haxe.Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe.ValueException.__name__ = true;
haxe.ValueException.__super__ = haxe.Exception;
Object.assign(haxe.ValueException.prototype, {
	__class__: haxe.ValueException
});
haxe.ds = {};
haxe.ds.ObjectMap = class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
}
haxe.ds.ObjectMap.__name__ = true;
haxe.ds.ObjectMap.__interfaces__ = [haxe.IMap];
Object.assign(haxe.ds.ObjectMap.prototype, {
	__class__: haxe.ds.ObjectMap
});
haxe.ds.StringMap = class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	static kvIterator(h) {
		let keys = Object.keys(h);
		let len = keys.length;
		let idx = 0;
		return { hasNext : function() {
			return idx < len;
		}, next : function() {
			idx += 1;
			let k = keys[idx - 1];
			return { key : k, value : h[k]};
		}};
	}
}
haxe.ds.StringMap.__name__ = true;
haxe.ds.StringMap.__interfaces__ = [haxe.IMap];
Object.assign(haxe.ds.StringMap.prototype, {
	__class__: haxe.ds.StringMap
});
haxe.io = {};
haxe.io.Eof = class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe.io.Eof.__name__ = true;
Object.assign(haxe.io.Eof.prototype, {
	__class__: haxe.io.Eof
});
haxe.iterators = {};
haxe.iterators.ArrayIterator = class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe.iterators.ArrayIterator.__name__ = true;
Object.assign(haxe.iterators.ArrayIterator.prototype, {
	__class__: haxe.iterators.ArrayIterator
});
var js = {};
js.Boot = class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js.Boot.__nativeClassName(o);
			if(name != null) {
				return js.Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js.Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js.Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js.Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		while(true) {
			if(cc == null) {
				return false;
			}
			if(cc == cl) {
				return true;
			}
			let intf = cc.__interfaces__;
			if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
				let _g = 0;
				let _g1 = intf.length;
				while(_g < _g1) {
					let i = intf[_g++];
					if(i == cl || js.Boot.__interfLoop(i,cl)) {
						return true;
					}
				}
			}
			cc = cc.__super__;
		}
	}
	static __implements(o,iface) {
		return js.Boot.__interfLoop(js.Boot.getClass(o),iface);
	}
	static __nativeClassName(o) {
		let name = js.Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js.Boot.__name__ = true;
function $iterator(o) { if( o instanceof Array ) return function() { return new haxe.iterators.ArrayIterator(o); }; return typeof(o.iterator) == 'function' ? $bind(o,o.iterator) : o.iterator; }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
function $arrayPush(x) { this.push(x); }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
haxe.ds.ObjectMap.count = 0;
js.Boot.__toStr = ({ }).toString;
cosy.Interpreter.__meta__ = { fields : { evaluate : { SuppressWarnings : ["checkstyle:CyclomaticComplexity","checkstyle:NestedControlFlow","checkstyle:MethodLength"]}}};
cosy.Interpreter.uninitialized = { };
cosy.Cosy.interpreter = new cosy.Interpreter();
cosy.Cosy.foreignFunctions = new haxe.ds.StringMap();
cosy.Cosy.foreignVariables = new haxe.ds.StringMap();
cosy.Cosy.hadError = false;
cosy.Cosy.hadRuntimeError = false;
cosy.Cosy.prettyPrint = false;
cosy.Cosy.javascript = false;
cosy.Cosy.testing = false;
cosy.Cosy.testOutput = "";
cosy.Scanner.keywords = (function($this) {
	var $r;
	let _g = new haxe.ds.StringMap();
	_g.h["and"] = cosy.TokenType.And;
	_g.h["break"] = cosy.TokenType.Break;
	_g.h["continue"] = cosy.TokenType.Continue;
	_g.h["else"] = cosy.TokenType.Else;
	_g.h["false"] = cosy.TokenType.False;
	_g.h["for"] = cosy.TokenType.For;
	_g.h["foreign"] = cosy.TokenType.Foreign;
	_g.h["fn"] = cosy.TokenType.Fn;
	_g.h["in"] = cosy.TokenType.In;
	_g.h["if"] = cosy.TokenType.If;
	_g.h["mut"] = cosy.TokenType.Mut;
	_g.h["or"] = cosy.TokenType.Or;
	_g.h["print"] = cosy.TokenType.Print;
	_g.h["return"] = cosy.TokenType.Return;
	_g.h["struct"] = cosy.TokenType.Struct;
	_g.h["true"] = cosy.TokenType.True;
	_g.h["var"] = cosy.TokenType.Var;
	_g.h["Bool"] = cosy.TokenType.BooleanType;
	_g.h["Num"] = cosy.TokenType.NumberType;
	_g.h["Str"] = cosy.TokenType.StringType;
	_g.h["Void"] = cosy.TokenType.VoidType;
	_g.h["Fn"] = cosy.TokenType.FunctionType;
	_g.h["Array"] = cosy.TokenType.ArrayType;
	$r = _g;
	return $r;
}(this));
cosy.Cosy.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=cosy.js.map